/// Registra ogni movimento di un articolo nell'inventario.
/// Ogni movimento ha un tipo (es. acquisto, vendita, uso per produzione)
/// che ne determina l'impatto sulla quantità in magazzino.
model Movement {
  /// ID univoco del movimento.
  id              String            @id @default(uuid())
  itemId          String?
  quantity        Int //sempre positivo
  type            MovementType
  date            DateTime          @default(now())
  productId       String?
  assemblyStageId String?
  productPartId   String?
  /// Perché: tracciare quando l'uscita è FBM o FBA; WIP resta NULL (condiviso).
  channel         InventoryChannel?
  /// Perché: quando scarico/spedisco per uno SKU specifico (FBA/FBM).
  skuId           String?
  sku             Sku?              @relation(fields: [skuId], references: [id])
  /// MIGLIORIA: collega il movimento all’odette dove vengono scaricati/prelevati i pezzi
  odetteId        String?
  odette          Odette?           @relation(fields: [odetteId], references: [id], onDelete: SetNull)
  lotId           String?
  lot             InventoryLot?     @relation(fields: [lotId], references: [id], onDelete: SetNull)
  /// Perché: tracciare quando l'entrata è FBM o FBA; WIP resta NULL (condiviso).
  assemblyStage   AssemblyStage?    @relation(fields: [assemblyStageId], references: [id])
  item            Item?             @relation(fields: [itemId], references: [id])
  productPart     ProductPart?      @relation(fields: [productPartId], references: [id])
  product         Product?          @relation(fields: [productId], references: [id])
  shipments       Shipment[]

  @@index([productPartId])
  @@index([assemblyStageId])
  @@index([productId])
  @@index([itemId])
  @@index([channel])
  @@index([skuId])
  @@index([odetteId])
  @@index([lotId])
  @@schema("inventory")
}

/// Lotto fisico di inventario (acquisto o produzione) per la tracciabilità ISO 9001.
/// Collega articoli/prodotti a ordini di acquisto, ordini di produzione, movimenti, odette e spedizioni.
model InventoryLot {
  id         String                 @id @default(uuid())
  code       String                 @unique
  originType InventoryLotOriginType

  /// Quantità iniziale teorica del lotto (pezzi ricevuti/prodotti)
  initialQuantity Int
  /// Stato logico del lotto (aperto/chiuso), indipendente dal conteggio movimenti
  status          InventoryLotStatus @default(OPEN)

  itemId    String?
  item      Item?    @relation(fields: [itemId], references: [id], onDelete: Restrict)
  productId String?
  product   Product? @relation(fields: [productId], references: [id], onDelete: Restrict)

  purchaseOrderLineId String?
  purchaseOrderLine   PurchaseOrderLine? @relation(fields: [purchaseOrderLineId], references: [id], onDelete: SetNull)
  supplierId          String?
  supplier            Supplier?          @relation(fields: [supplierId], references: [id], onDelete: SetNull)
  supplierLotCode     String?

  productItemOrderId String?
  productItemOrder   ProductOrder?  @relation(fields: [productItemOrderId], references: [id], onDelete: SetNull)
  assemblyOrderId    String?
  assemblyOrder      AssemblyOrder? @relation(fields: [assemblyOrderId], references: [id], onDelete: SetNull)
  /// Lotto di produzione stampa 3D da cui deriva (se applicabile).
  productionLotId    String?
  productionLot      ProductionLot? @relation(fields: [productionLotId], references: [id], onDelete: SetNull)

  manufacturedAt DateTime?
  receivedAt     DateTime?
  expiryDate     DateTime?
  note           String?

  movements      Movement[]
  odetteContents OdetteContent[]

  shipmentLines      ShipmentLine[]
  assemblyOperations AssemblyOperation[]

  /// Bobine di filamento associate a questo lotto di inventario.
  filamentSpools FilamentSpool[] @relation("InventoryLotFilamentSpools")
  lotInspections LotInspection[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([originType])
  @@index([status])
  @@index([itemId])
  @@index([productId])
  @@index([purchaseOrderLineId])
  @@index([productItemOrderId])
  @@index([assemblyOrderId])
  @@index([supplierId])
  @@index([productionLotId])
  @@schema("inventory")
}

/// Rappresenta una fila/riga fisica di scaffale o area di magazzino (es. "A", "B", "PF-1").
model WarehouseRow {
  id          String  @id @default(uuid())
  /// Codice leggibile che appare sui cartelli fisici (es. "A", "B", "PF-1").
  code        String  @unique
  /// Descrizione opzionale (es. "Print Farm fila A", "Assemblaggio fila 1").
  description String?

  /// Tutte le posizioni (slot) appartenenti a questa fila.
  locations WarehouseLocation[]

  @@schema("inventory")
}

/// Definisce una posizione fisica nel magazzino dove gli articoli possono essere stoccati.
model WarehouseLocation {
  id   String @id @default(uuid())
  name String @unique

  /// Fila di appartenenza (scaffale/linea fisica).
  rowId String?
  row   WarehouseRow? @relation(fields: [rowId], references: [id], onDelete: SetNull)

  /// Posizione progressiva all'interno della stessa fila (1, 2, 3...).
  positionInRow Int?

  /// Tipo di posizione (slot generico, testa odette, scaffale materiali, area assemblaggio, ...).
  kind WarehouseLocationKind @default(SLOT)

  printers Printer[]

  /// Tipo di articolo associato a questa posizione.
  /// Se `null`, la posizione è considerata "generica" (nessun vincolo sul tipo).
  associatedItemType ItemType?
  items              Item[]
  skus               Sku[]
  odetteMovesFrom    OdetteMove[] @relation("OdetteMoveFrom")
  odetteMovesTo      OdetteMove[] @relation("OdetteMoveTo")
  odettes            Odette[]

  odetteLocationPreferences OdetteLocationPreference[]

  @@index([name])
  @@index([rowId, positionInRow])
  @@index([kind])
  @@index([associatedItemType])
  @@schema("inventory")
}

/// Tipologia logica di posizione di magazzino.
enum WarehouseLocationKind {
  /// Slot generico, posizione standard su scaffale.
  SLOT
  /// Posizione dove è fisicamente installata una stampante.
  PRINTER_SLOT
  /// Testa fila destinata a odette di scarico/accumulo.
  ODETTE_HEAD
  /// Scaffale/area dove stazionano le odette vuote (storage).
  ODETTE_EMPTY_STORAGE
  /// Area coda Print Farm: odette riservate/accodate in attesa di essere riempite o scaricate.
  ODETTE_PRINT_FARM_QUEUE
  /// Area/buffer reparto assemblaggio: odette sorgenti/destinazione per picking/assembly.
  ODETTE_ASSEMBLY_BUFFER
  /// Scaffale/area odette piene (separate dalle altre zone).
  ODETTE_FULL_STORAGE
  /// Scaffale per materiali/filamenti sotto la fila stampanti.
  MATERIAL_SHELF
  /// Area di buffer/intermedio.
  BUFFER
  /// Posizione in reparto assemblaggio.
  ASSEMBLY

  @@schema("inventory")
}

/// Ispezione qualità/accettazione per un lotto di inventario (ISO 9001).
model LotInspection {
  id String @id @default(uuid())

  lotId String
  lot   InventoryLot @relation(fields: [lotId], references: [id], onDelete: Cascade)

  inspectedAt DateTime @default(now())

  inspectedBy Int?
  inspector   User? @relation(fields: [inspectedBy], references: [id], onDelete: SetNull)

  result LotInspectionResult
  notes  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([lotId])
  @@index([inspectedBy])
  @@schema("inventory")
}

/// Esito ispezione lotto (qualità).
enum LotInspectionResult {
  PASSED /// Lotto conforme
  FAILED /// Lotto non conforme
  REWORK /// Lotto da rilavorare/parzialmente accettato
  BLOCKED /// Lotto bloccato in attesa decisione

  @@schema("inventory")
}

/// MIGLIORIA: allocare quantità "finite" a canali/SKU
/// Perché: poter dire “100 FBA e 5 FBM” senza duplicare ProductItem.
/// Nota: si può opzionalmente legare a una specifica fase finita (assemblyStageId)
/// e (consigliato) a uno SKU (skuId) quando il canale/mercato lo impone.
model FinishedAllocation {
  id              String           @id @default(uuid())
  productItemId   String
  assemblyStageId String?
  channel         InventoryChannel
  quantity        Int
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  skuId String?
  sku   Sku?    @relation(fields: [skuId], references: [id])

  product       Product        @relation(fields: [productItemId], references: [id], onDelete: Cascade)
  assemblyStage AssemblyStage? @relation(fields: [assemblyStageId], references: [id])

  /// MIGLIORIA: unique composito per evitare allocazioni duplicate della stessa chiave logica
  @@unique([productItemId, assemblyStageId, channel, skuId])
  @@index([productItemId, channel])
  @@index([skuId])
  @@schema("inventory")
}

/// Tipi di movimento di inventario.
enum MovementType {
  USO // uscita per utilizzo in produzione
  ACQUISTO //entrata da ordine fornitore
  VENDITA // uscita per vendita cliente

  STAGE_IN // entrata in una fase di assemblaggio
  STAGE_OUT // uscita da una fase di assemblaggio
  PRODUZIONE // entrata da produzione completata
  RIMBORSO_PRODUZIONE // entrata per annullamento produzione
  RIMBORSO_USO // entrata per annullamento uso
  TRASH // uscita per scarto/rottura
  CORRECTION_UP // entrata per correzione quantità (aumento)
  CORRECTION_DOWN // uscita per correzione quantità (diminuzione)

  @@schema("inventory")
}

/// Perché: separare allocazioni FBA/FBM senza duplicare il ProductItem.
enum InventoryChannel {
  UNALLOCATED
  FBM
  FBA
  CUSTOM

  @@schema("inventory")
}

enum InventoryLotOriginType {
  PURCHASE
  PRODUCTION
  ADJUSTMENT
  OTHER

  @@schema("inventory")
}

enum InventoryLotStatus {
  OPEN
  CLOSED

  @@schema("inventory")
}
