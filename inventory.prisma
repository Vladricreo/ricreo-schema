/// Registra ogni movimento di un articolo nell'inventario.
/// Ogni movimento ha un tipo (es. acquisto, vendita, uso per produzione)
/// che ne determina l'impatto sulla quantità in magazzino.
model Movement {
  /// ID univoco del movimento.
  id              String            @id @default(uuid()) @db.Uuid
  itemId          String?           @db.Uuid
  /// Spec/famiglia logica che ha guidato la selezione dell'Item (audit per fallback).
  itemSpecId      String?           @db.Uuid
  quantity        Int //sempre positivo
  type            MovementType
  date            DateTime          @default(now()) @db.Timestamptz(6)
  /// Utente che ha eseguito il movimento (audit).
  byUserId        Int?              @db.Integer
  byUser          User?             @relation(fields: [byUserId], references: [id], onDelete: SetNull)
  productId       String?           @db.Uuid
  /// Collega il movimento all'ordine di assemblaggio (audit per-task).
  assemblyOrderId String?           @db.Uuid
  assemblyOrder   AssemblyOrder?    @relation(fields: [assemblyOrderId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  /// Collega il movimento all'ordine di produzione (per progetti futuri / audit).
  productOrderId  String?           @db.Uuid
  productOrder    ProductOrder?     @relation(fields: [productOrderId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  assemblyStageId String?           @db.Uuid
  productPartId   String?           @db.Uuid
  /// Perché: tracciare quando l'uscita è FBM o FBA; WIP resta NULL (condiviso).
  channel         InventoryChannel?
  /// Perché: quando scarico/spedisco per uno SKU specifico (FBA/FBM).
  skuId           String?           @db.Uuid
  sku             Sku?              @relation(fields: [skuId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  /// MIGLIORIA: collega il movimento all’odette dove vengono scaricati/prelevati i pezzi
  odetteId        String?           @db.Uuid
  odette          Odette?           @relation(fields: [odetteId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  lotId           String?           @db.Uuid
  lot             InventoryLot?     @relation(fields: [lotId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  /// Perché: tracciare quando l'entrata è FBM o FBA; WIP resta NULL (condiviso).
  assemblyStage   AssemblyStage?    @relation(fields: [assemblyStageId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  item            Item?             @relation(fields: [itemId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  itemSpec        ItemSpec?         @relation(fields: [itemSpecId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  productPart     ProductPart?      @relation(fields: [productPartId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  product         Product?          @relation(fields: [productId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  shipments       Shipment[]

  @@index([productPartId])
  @@index([assemblyStageId])
  @@index([productId])
  @@index([itemId])
  @@index([itemSpecId])
  @@index([channel])
  @@index([skuId])
  @@index([odetteId])
  @@index([lotId])
  @@index([byUserId])
  @@index([assemblyOrderId])
  @@index([productOrderId])
  @@index([assemblyOrderId, assemblyStageId, type])
  @@index([assemblyOrderId, date(sort: Desc)])
  @@index([date(sort: Desc)])
  @@schema("inventory")
}

/// Lotto fisico di inventario (acquisto o produzione) per la tracciabilità ISO 9001.
/// Collega articoli/prodotti a ordini di acquisto, ordini di produzione, movimenti, odette e spedizioni.
model InventoryLot {
  id         String                 @id @default(uuid()) @db.Uuid
  /// Progressivo numerico leggibile (BIGINT Postgres) per uso umano/reportistica.
  /// Nota: lasciamo `id` UUID come PK; questo è solo un numero sequenziale (compatibile Supabase).
  number     BigInt                 @unique @default(autoincrement()) @db.BigInt
  code       String                 @unique
  originType InventoryLotOriginType

  /// Quantità iniziale teorica del lotto (pezzi ricevuti/prodotti)
  initialQuantity Int
  /// Stato logico del lotto (aperto/chiuso), indipendente dal conteggio movimenti
  status          InventoryLotStatus @default(OPEN)

  itemId        String?      @db.Uuid
  item          Item?        @relation(fields: [itemId], references: [id], onDelete: Restrict)
  productId     String?      @db.Uuid
  product       Product?     @relation(fields: [productId], references: [id], onDelete: Restrict)
  /// Opzionale: lotto riferito a una singola ProductPart (per acquisti di parti esterne).
  productPartId String?      @db.Uuid
  productPart   ProductPart? @relation(fields: [productPartId], references: [id], onDelete: Restrict)

  purchaseOrderLineId String?            @db.Uuid
  purchaseOrderLine   PurchaseOrderLine? @relation(fields: [purchaseOrderLineId], references: [id], onDelete: SetNull)
  supplierId          String?            @db.Uuid
  supplier            Supplier?          @relation(fields: [supplierId], references: [id], onDelete: SetNull)
  supplierLotCode     String?

  productItemOrderId String?        @db.Uuid
  productItemOrder   ProductOrder?  @relation(fields: [productItemOrderId], references: [id], onDelete: SetNull)
  assemblyOrderId    String?        @db.Uuid
  assemblyOrder      AssemblyOrder? @relation(fields: [assemblyOrderId], references: [id], onDelete: SetNull)
  /// Lotto di produzione stampa 3D da cui deriva (se applicabile).
  productionLotId    String?        @db.Uuid
  productionLot      ProductionLot? @relation(fields: [productionLotId], references: [id], onDelete: SetNull)

  manufacturedAt DateTime? @db.Timestamptz(6)
  receivedAt     DateTime? @db.Timestamptz(6)
  expiryDate     DateTime? @db.Timestamptz(6)
  note           String?

  movements      Movement[]
  odetteContents OdetteContent[]

  shipmentLines      ShipmentLine[]
  assemblyOperations AssemblyOperation[]

  /// Bobine di filamento associate a questo lotto di inventario.
  filamentSpools FilamentSpool[] @relation("InventoryLotFilamentSpools")
  lotInspections LotInspection[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([originType])
  @@index([status])
  @@index([itemId])
  @@index([productId])
  @@index([productPartId])
  @@index([purchaseOrderLineId])
  @@index([productItemOrderId])
  @@index([assemblyOrderId])
  @@index([supplierId])
  @@index([productionLotId])
  @@schema("inventory")
}

/// Gruppo/Fila fisica che contiene più scaffali (es. "A", "PF", "MAG-1").
/// Perché: rendere persistente il concetto di "fila" (ordine, nome, descrizione) anche quando è vuota.
model WarehouseShelfGroup {
  id String @id @default(uuid()) @db.Uuid

  /// Codice univoco leggibile (es. "A", "PF", "MAG-1").
  code String @unique

  /// Nome descrittivo mostrato in UI (es. "Fila A", "Print Farm").
  name String

  /// Descrizione opzionale.
  description String?

  /// Ordine globale del gruppo nella UI (1..N).
  order Int

  /// Scaffali appartenenti al gruppo.
  shelves WarehouseShelf[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([order])
  @@index([code])
  @@index([order])
  @@schema("inventory")
}

/// Rappresenta uno scaffale fisico (contenitore) che raggruppa più ripiani/righe.
model WarehouseShelf {
  id          String  @id @default(uuid()) @db.Uuid
  /// Codice leggibile (es. "S-01", "MAG-A").
  code        String  @unique
  /// Nome descrittivo (es. "Scaffale Imballi", "Scaffale Print Farm").
  name        String
  /// Descrizione opzionale.
  description String?
  /// Immagine opzionale (usata dalla UI).
  imageUrl    String?

  /// Gruppo/Fila fisica di appartenenza (opzionale: equivale a "Senza fila").
  groupId String?             @db.Uuid
  group   WarehouseShelfGroup? @relation(fields: [groupId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Posizione progressiva dello scaffale all'interno del gruppo (1..N).
  positionInGroup Int?

  /// Ripiani/righe fisiche appartenenti allo scaffale.
  rows WarehouseRow[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([code])
  @@index([name])
  @@index([groupId, positionInGroup])
  @@unique([groupId, positionInGroup])
  @@schema("inventory")
}

/// Rappresenta una fila/riga fisica di scaffale o area di magazzino (es. "A", "B", "PF-1").
model WarehouseRow {
  id          String  @id @default(uuid()) @db.Uuid
  /// Codice leggibile che appare sui cartelli fisici (es. "A", "B", "PF-1").
  code        String  @unique
  /// Descrizione opzionale (es. "Print Farm fila A", "Assemblaggio fila 1").
  description String?

  /// Scaffale di appartenenza (opzionale: alcune righe possono essere "libere").
  shelfId      String?         @db.Uuid
  shelf        WarehouseShelf? @relation(fields: [shelfId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  /// Ordine del ripiano all'interno dello scaffale (1..N).
  orderInShelf Int?

  /// Tipo di contenuto della riga (determina cosa può essere allocato).
  rowType WarehouseRowType @default(MIXED)

  /// Filtro opzionale per tipo ITEM: categoria principale (MATERIAL, PACKAGING, etc.).
  itemType ItemType?

  /// Filtro opzionale per tipo ITEM: sottocategoria.
  categoryId String?   @db.Uuid
  category   Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Tutte le posizioni (slot) appartenenti a questa fila.
  locations WarehouseLocation[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([shelfId])
  @@index([shelfId, orderInShelf])
  @@index([rowType])
  @@index([itemType])
  @@index([categoryId])
  @@schema("inventory")
}

/// Tipo di contenuto di una riga/ripiano di scaffale.
enum WarehouseRowType {
  /// Slot per stampanti 3D.
  PRINTER
  /// Item generici (filtra per ItemType + Category).
  ITEM
  /// Prodotti FBA.
  PRODUCT_FBA
  /// Prodotti FBM.
  PRODUCT_FBM
  /// Prodotti custom.
  PRODUCT_CUSTOM
  /// Odette con prodotti assemblati.
  ODETTE_ASSEMBLED
  /// Odette per scarico stampanti.
  ODETTE_UNLOAD
  /// Ripiano dedicato alle bobine parzialmente usate.
  SPOOL_STORAGE
  /// Qualsiasi cosa (nessun filtro).
  MIXED

  @@schema("inventory")
}

/// Definisce una posizione fisica nel magazzino dove gli articoli possono essere stoccati.
model WarehouseLocation {
  id   String @id @default(uuid()) @db.Uuid
  name String @unique

  /// Fila di appartenenza (scaffale/linea fisica).
  rowId String?       @db.Uuid
  row   WarehouseRow? @relation(fields: [rowId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  /// Posizione progressiva all'interno della stessa fila (1, 2, 3...).
  positionInRow Int?

  /// Tipo di posizione (slot generico, testa odette, scaffale materiali, area assemblaggio, ...).
  kind WarehouseLocationKind @default(SLOT)

  printers Printer[]

  /// Tipo di articolo associato a questa posizione.
  /// Se `null`, la posizione è considerata "generica" (nessun vincolo sul tipo).
  associatedItemType ItemType?
  items              Item[]
  skus               Sku[]
  odetteMovesFrom    OdetteMove[] @relation("OdetteMoveFrom")
  odetteMovesTo      OdetteMove[] @relation("OdetteMoveTo")
  odettes            Odette[]

  /// Allocazioni di quantità (multi-location) per Item/SKU.
  itemAllocations WarehouseItemAllocation[]
  skuAllocations  WarehouseSkuAllocation[]

  odetteLocationPreferences OdetteLocationPreference[]

  /// Bobine filamento stoccate in questa posizione
  filamentSpools FilamentSpool[] @relation("SpoolLocation")

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([name])
  @@index([rowId, positionInRow])
  @@index([kind])
  @@index([associatedItemType])
  @@schema("inventory")
}

/// Quantità di un Item allocata in una specifica posizione di magazzino.
/// Serve per supportare lo stesso Item presente in più slot contemporaneamente.
model WarehouseItemAllocation {
  id String @id @default(uuid()) @db.Uuid

  locationId String            @db.Uuid
  location   WarehouseLocation @relation(fields: [locationId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  itemId String @db.Uuid
  item   Item   @relation(fields: [itemId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  /// Quantità attualmente presente nello slot (sempre >= 0 lato applicativo).
  quantity Int @default(0)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([locationId, itemId])
  @@index([locationId])
  @@index([itemId])
  @@schema("inventory")
}

/// Quantità di uno SKU allocata in una specifica posizione di magazzino.
/// Serve per prodotti finiti/stock per canale.
model WarehouseSkuAllocation {
  id String @id @default(uuid()) @db.Uuid

  locationId String            @db.Uuid
  location   WarehouseLocation @relation(fields: [locationId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  skuId String @db.Uuid
  sku   Sku    @relation(fields: [skuId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  /// Quantità attualmente presente nello slot (sempre >= 0 lato applicativo).
  quantity Int @default(0)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([locationId, skuId])
  @@index([locationId])
  @@index([skuId])
  @@schema("inventory")
}

/// Tipologia logica di posizione di magazzino.
enum WarehouseLocationKind {
  /// Slot generico, posizione standard su scaffale.
  SLOT
  /// Posizione dove è fisicamente installata una stampante.
  PRINTER_SLOT
  /// Testa fila destinata a odette di scarico/accumulo.
  ODETTE_HEAD
  /// Scaffale/area dove stazionano le odette vuote (storage).
  ODETTE_EMPTY_STORAGE
  /// Area coda Print Farm: odette riservate/accodate in attesa di essere riempite o scaricate.
  ODETTE_PRINT_FARM_QUEUE
  /// Area/buffer reparto assemblaggio: odette sorgenti/destinazione per picking/assembly.
  ODETTE_ASSEMBLY_BUFFER
  /// Scaffale/area odette piene (separate dalle altre zone).
  ODETTE_FULL_STORAGE
  /// Scaffale per materiali/filamenti sotto la fila stampanti.
  MATERIAL_SHELF
  /// Area di buffer/intermedio.
  BUFFER
  /// Posizione in reparto assemblaggio.
  ASSEMBLY
  /// Area dedicata allo stoccaggio di bobine/spool parzialmente usate.
  SPOOL_STORAGE

  @@schema("inventory")
}

/// Ispezione qualità/accettazione per un lotto di inventario (ISO 9001).
model LotInspection {
  id String @id @default(uuid()) @db.Uuid

  lotId String       @db.Uuid
  lot   InventoryLot @relation(fields: [lotId], references: [id], onDelete: Cascade)

  inspectedAt DateTime @default(now()) @db.Timestamptz(6)

  inspectedBy Int?
  inspector   User? @relation(fields: [inspectedBy], references: [id], onDelete: SetNull)

  result LotInspectionResult
  notes  String?

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([lotId])
  @@index([inspectedBy])
  @@schema("inventory")
}

/// Esito ispezione lotto (qualità).
enum LotInspectionResult {
  PASSED /// Lotto conforme
  FAILED /// Lotto non conforme
  REWORK /// Lotto da rilavorare/parzialmente accettato
  BLOCKED /// Lotto bloccato in attesa decisione

  @@schema("inventory")
}

/// MIGLIORIA: allocare quantità "finite" a canali/SKU
/// Perché: poter dire “100 FBA e 5 FBM” senza duplicare ProductItem.
/// Nota: si può opzionalmente legare a una specifica fase finita (assemblyStageId)
/// e (consigliato) a uno SKU (skuId) quando il canale/mercato lo impone.
model FinishedAllocation {
  id              String           @id @default(uuid()) @db.Uuid
  productItemId   String           @db.Uuid
  assemblyStageId String?          @db.Uuid
  channel         InventoryChannel
  quantity        Int
  createdAt       DateTime         @default(now()) @db.Timestamptz(6)
  updatedAt       DateTime         @default(now()) @updatedAt @db.Timestamptz(6)

  skuId String? @db.Uuid
  sku   Sku?    @relation(fields: [skuId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  product       Product        @relation(fields: [productItemId], references: [id], onDelete: Cascade)
  assemblyStage AssemblyStage? @relation(fields: [assemblyStageId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// MIGLIORIA: unique composito per evitare allocazioni duplicate della stessa chiave logica
  @@unique([productItemId, assemblyStageId, channel, skuId])
  @@index([productItemId, channel])
  @@index([skuId])
  @@schema("inventory")
}

/// Tipi di movimento di inventario.
enum MovementType {
  USO // uscita per utilizzo in produzione
  ACQUISTO //entrata da ordine fornitore
  VENDITA // uscita per vendita cliente

  STAGE_IN // entrata in una fase di assemblaggio
  STAGE_OUT // uscita da una fase di assemblaggio
  PRODUZIONE // entrata da produzione completata
  RIMBORSO_PRODUZIONE // entrata per annullamento produzione
  RIMBORSO_USO // entrata per annullamento uso
  TRASH // uscita per scarto/rottura
  CORRECTION_UP // entrata per correzione quantità (aumento)
  CORRECTION_DOWN // uscita per correzione quantità (diminuzione)

  @@schema("inventory")
}

/// Perché: separare allocazioni FBA/FBM senza duplicare il ProductItem.
enum InventoryChannel {
  UNALLOCATED
  FBM
  FBA
  CUSTOM

  @@schema("inventory")
}

enum InventoryLotOriginType {
  PURCHASE
  PRODUCTION
  ADJUSTMENT
  OTHER

  @@schema("inventory")
}

enum InventoryLotStatus {
  OPEN
  CLOSED

  @@schema("inventory")
}
