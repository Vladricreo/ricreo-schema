/// Modello generico per qualsiasi articolo gestito in inventario.
/// Può rappresentare materie prime, imballaggi, componenti, accessori, ricambi, attrezzi o prodotti finiti.
/// Il campo 'type' (ItemType) distingue la natura specifica dell'articolo.
model Item {
  id       String  @id @default(uuid()) @db.Uuid
  imageUrl String?
  name     String
  sku      String  @unique

  price  Decimal  @db.Decimal(12, 2) /// prima: Float
  weight Decimal? @db.Decimal(12, 2) /// prima: Float?
  /// Tipologia di articolo (es. MATERIALE, IMBALLAGGIO, COMPONENTE).
  type   ItemType

  /// Specifica/famiglia logica a cui questo Item appartiene (per gestire alternative/fallback).
  itemSpecId   String? @db.Uuid
  /// Priorità del variant dentro la stessa spec (0 = default/preferito).
  specPriority Int     @default(0)

  categoryId       String? @db.Uuid
  colorId          String? @db.Uuid
  brandId          String? @db.Uuid
  supplierId       String? @db.Uuid
  locationId       String? @db.Uuid
  standardWeightId String? @db.Uuid
  dimensionsId     String? @db.Uuid

  properties Json?

  inStock  Int @default(0)
  reserved Int @default(0)
  onOrder  Int @default(0)
  minStock Int @default(0)
  maxStock Int @default(0)
  minOrder Int @default(0)
  maxOrder Int @default(0)

  createdAt       DateTime @default(now()) @db.Timestamptz(6)
  updatedAt       DateTime @default(now()) @updatedAt @db.Timestamptz(6)
  packagingTypeId String?  @db.Uuid

  brand          Brand?             @relation(fields: [brandId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  category       Category?          @relation(fields: [categoryId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  color          Color?             @relation(fields: [colorId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  location       WarehouseLocation? @relation(fields: [locationId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  packagingType  PackagingType?     @relation(fields: [packagingTypeId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  standardWeight StandardWeight?    @relation(fields: [standardWeightId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  supplier       Supplier?          @relation(fields: [supplierId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  dimensions     Dimensions?        @relation(fields: [dimensionsId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  itemSpec       ItemSpec?          @relation(fields: [itemSpecId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Allocazioni multi-location per questo Item (quantità per slot).
  warehouseItemAllocations WarehouseItemAllocation[]

  movements Movement[]

  /// Override (emergenze) che forzano questo Item come variant per una spec.
  itemSpecOverrideEntries ItemSpecOverride[] @relation("ItemSpecOverrideItem")

  parts                     ProductPart[]       @relation("ItemToItemPart")
  /// Righe BOM (ProductPartMaterial) che puntano a questo Item (variant specifico).
  partMaterialBreakdowns    ProductPartMaterial[] @relation("ProductPartMaterialItem")
  ordersofitemforproduction ProductOrderItem[]
  purchaseOrderLines        PurchaseOrderLine[]
  product                   Product[]
  compatibleMachines        CompatibleMachine[] @relation("SpareParts")
  OdetteContent             OdetteContent[]
  lots                      InventoryLot[]
  pickingLines              PickingLine[]

  // Relazioni Print Farm
  projectFiles      ProjectThreeMFFile[]
  fileMaterialUsage ProjectFileMaterial[] @relation("FileMaterialUsage") // Uso materiale nei file con peso specifico
  productionJobs    ProductionJob[]
  printRuns         PrintRun[]
  spools            FilamentSpool[]
  filamentProfile   FilamentProfile? // Profilo tecnico per materiali (solo per type=MATERIAL)

  @@index([type])
  @@index([categoryId])
  @@index([colorId])
  @@index([brandId])
  @@index([supplierId])
  @@index([locationId])
  @@index([itemSpecId, specPriority])
  @@schema("inventory")
}

/// Specifica/famiglia logica di Item intercambiabili (per BOM e fallback).
/// Esempi: "Scatola 20x10x30", "PLA Nero 1kg", "Vite M3x10".
model ItemSpec {
  id   String   @id @default(uuid()) @db.Uuid
  name String
  type ItemType

  /// Solo per spec di PACKAGING: collega un PackagingType (PRIMARY/SECONDARY/OTHERS).
  packagingTypeId String?        @db.Uuid
  packagingType   PackagingType? @relation(fields: [packagingTypeId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  notes      String?
  properties Json?

  items     Item[]
  overrides ItemSpecOverride[]

  /// BOM: il prodotto richiede una spec (non un item specifico)
  productComponents ProductToComponent[]
  productPackages   ProductToPackage[]
  productTools      ProductToTool[]
  productUtilities  ProductToUtility[]
  partMaterials     ProductPartMaterial[]

  movements Movement[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([type])
  @@index([name])
  @@index([packagingTypeId])
  @@schema("inventory")
}

/// Override temporaneo: forza un Item specifico come variant attivo per una spec.
/// Usato per sostituzioni straordinarie con autorizzazione e motivo.
model ItemSpecOverride {
  id String @id @default(uuid()) @db.Uuid

  specId String   @unique @db.Uuid
  spec   ItemSpec @relation(fields: [specId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  itemId String @db.Uuid
  item   Item   @relation("ItemSpecOverrideItem", fields: [itemId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  isActive Boolean   @default(true)
  startsAt DateTime  @default(now()) @db.Timestamptz(6)
  endsAt   DateTime? @db.Timestamptz(6)

  /// Motivo operatore/supervisor (audit).
  reason String

  approvedByUserId Int?  @db.Integer
  approvedByUser   User? @relation("ApprovedItemSpecOverrides", fields: [approvedByUserId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([itemId])
  @@index([isActive])
  @@index([approvedByUserId])
  @@schema("inventory")
}

/// Modello per un prodotto finito, vendibile.
/// Un prodotto è composto da vari 'Item' (componenti, materiali) e può avere più fasi di assemblaggio.
/// Gestisce informazioni su costi, prezzi, e logistica (FBM/FBA).
model Product {
  id        String  @id @unique @default(uuid()) @db.Uuid
  imageUrl  String?
  treemfUrl String?
  name      String
  asin      String?
  ean       String?

  cost           Decimal  @default(0) @db.Decimal(12, 2) /// prima: Float
  estimatedPrice Decimal? @db.Decimal(12, 2) /// prima: Float?
  sellingPrice   Decimal? @db.Decimal(12, 2) /// prima: Float?
  profitMargin   Decimal? @db.Decimal(5, 4) /// prima: Float? (0.1234 = 12.34%)
  laborCost      Decimal? @db.Decimal(12, 2) /// prima: Float?
  laborMinutes   Decimal? @db.Decimal(8, 2) /// prima: Float?
  shippingCost   Decimal? @db.Decimal(12, 2)
  dimensionsId   String?  @db.Uuid

  itemId     String?  @db.Uuid
  properties Json?
  createdAt  DateTime @default(now()) @db.Timestamptz(6)
  updatedAt  DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  skus Sku[]

  minStock Int @default(5)
  minOrder Int @default(0) // Lotto minimo di produzione (batching)

  // Campi per ottimizzazione dinamica (Velocity)
  averageDailySales    Decimal?  @db.Decimal(12, 2)
  suggestedMinStock    Int?
  autoAdjustMinStock   Boolean   @default(false)
  lastSalesCalculation DateTime? @db.Timestamptz(6)

  amazonProduct  AmazonProduct?
  stages         AssemblyStage[]
  guides         Guide[]
  warnings       Warning[]
  parts          ProductPart[]
  movements      Movement[]
  /// Relazione opzionale verso l'Item collegato
  item           Item?                @relation(fields: [itemId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  components     ProductToComponent[] @relation("ProductComponents")
  productOrders  ProductOrder[]
  packages       ProductToPackage[]   @relation("ProductPackages")
  tools          ProductToTool[]      @relation("ProductTools")
  utilities      ProductToUtility[]   @relation("ProductUtilities")
  shipments      Shipment[]
  assemblyOrders AssemblyOrder[]
  dimensions     Dimensions?          @relation(fields: [dimensionsId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  finishedAllocations FinishedAllocation[]
  lots                InventoryLot[]

  // Relazioni Print Farm
  projectFiles   ProjectThreeMFFile[]
  projectParts   ProjectPart[]
  productionJobs ProductionJob[]

  @@index([itemId])
  @@schema("inventory")
}

/// Rappresenta un sotto-assieme o una parte stampata in 3D di un 'ProductItem'.
model ProductPart {
  id                 String                    @id @unique @default(uuid()) @db.Uuid
  imageUrl           String?
  name               String
  price              Decimal?                  @db.Decimal(12, 2) /// prima: Float?
  properties         Json?
  /// Indica se la parte viene prodotta internamente (MAKE) o acquistata (BUY).
  sourceType         PartSourceType            @default(MAKE)
  /// Fornitore preferenziale per parti acquistate (BUY). Opzionale.
  supplierId         String?                   @db.Uuid
  productId          String                    @db.Uuid
  quantityNeeded     Int                       @default(0)
  dimensionsId       String?                   @db.Uuid
  dimensions         Dimensions?               @relation(fields: [dimensionsId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  inStock            Int                       @default(0)
  onOrder            Int                       @default(0)
  product            Product                   @relation(fields: [productId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  supplier           Supplier?                 @relation("SupplierProductParts", fields: [supplierId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  /// Righe ordine di acquisto collegate a questa parte (acquisto di parti esterne).
  purchaseOrderLines PurchaseOrderLine[]
  /// Lotti fisici collegati a questa parte (tracciabilità / acquisti parti esterne).
  lots               InventoryLot[]
  movements          Movement[]
  productOrders      ProductOrderProductPart[]
  materials          Item[]                    @relation("ItemToItemPart")
  /// Distinta base (BOM) della parte: materiali e grammi per singola parte.
  materialBreakdown  ProductPartMaterial[]

  OdetteContent OdetteContent[]
  pickingLines  PickingLine[]

  // Relazioni Print Farm
  projectParts       ProjectPart[]
  projectFiles       ProjectThreeMFFile[] @relation("ProductPartFiles")
  productionJobs     ProductionJob[]
  printerAssignments PrinterAssignment[]  @relation("ProductPartAssignments")

  @@index([productId])
  @@index([supplierId])
  @@schema("inventory")
}

/// Distinta base (BOM) di una `ProductPart`: collega un materiale (`Item`) ai grammi usati per UNA singola parte.
/// Serve per avere più materiali e pesi per la stessa parte (es. multi-materiale / inserti).
model ProductPartMaterial {
  id String @id @default(uuid()) @db.Uuid

  productPartId String      @db.Uuid
  productPart   ProductPart @relation(fields: [productPartId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  /// Variante specifica (Item) usata nella BOM.
  /// Serve per distinguere materiali diversi anche se raggruppati sotto la stessa ItemSpec.
  materialItemId String? @db.Uuid
  materialItem   Item?   @relation("ProductPartMaterialItem", fields: [materialItemId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  materialSpecId String   @db.Uuid
  materialSpec   ItemSpec @relation(fields: [materialSpecId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  /// Grammi di questo materiale usati per UNA singola parte.
  usedWeight Decimal @default(0) @db.Decimal(12, 2)

  /// Ordine/precedenza nella BOM della parte (0 = prima scelta).
  priority Int @default(0)

  notes String?

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  // Unicità per-variant (Item): permette più righe per la stessa spec se i materiali sono diversi.
  @@unique([productPartId, materialItemId])
  @@index([productPartId])
  @@index([materialSpecId])
  @@index([materialItemId])
  @@schema("inventory")
}

model Dimensions {
  id            String          @id @unique @default(uuid()) @db.Uuid
  width         Decimal         @default(0) @db.Decimal(12, 2)
  height        Decimal         @default(0) @db.Decimal(12, 2)
  depth         Decimal         @default(0) @db.Decimal(12, 2)
  poductpart    ProductPart[]
  item          Item[]
  product       Product[]
  amazonProduct AmazonProduct[]
  odetteType    OdetteType[]
  sku           Sku[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@schema("inventory")
}

/// Rappresenta una singola fase nel processo di assemblaggio di un 'Product'.
/// Include informazioni come il tempo di assemblaggio, l'ordine e il tipo di fase.
model AssemblyStage {
  id                  String               @id @unique @default(uuid()) @db.Uuid
  imageUrl            String?
  name                String
  productId           String               @db.Uuid
  order               Int?                 @default(0)
  instock             Int?                 @default(0)
  description         String?
  /// Tempo in minuti richiesto per completare questa fase.
  assemblyTime        Int                  @default(0)
  type                AssemblyStageType    @default(ASSEMBLED)
  product             Product              @relation(fields: [productId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  movements           Movement[]
  finishedAllocations FinishedAllocation[]

  assemblyOperations AssemblyOperation[]

  /// Relazioni many-to-many con Guide e Warning
  guideLinks   GuideToAssemblyStage[]
  warningLinks WarningToAssemblyStage[]

  /// Relazione con le utility assegnate a questa fase
  utilities ProductToUtility[]

  /// Relazione con i packaging assegnati a questa fase
  packages ProductToPackage[]

  odetteContents OdetteContent[]

  createdAt           DateTime             @default(now()) @db.Timestamptz(6)
  updatedAt           DateTime             @default(now()) @updatedAt @db.Timestamptz(6)
  productToComponents ProductToComponent[]

  @@unique([productId, name])
  @@index([productId])
  @@schema("inventory")
}

/// Guida di assemblaggio associata a un Product.
/// Puo essere associata a zero, uno o piu AssemblyStages tramite la tabella di join.
/// Se non ha stages associati, la guida si applica a tutto il prodotto.
model Guide {
  id           String  @id @default(uuid()) @db.Uuid
  title        String
  description  String? @db.Text
  url          String? /// URL esterno (es. YouTube, documentazione)
  imageUrl     String? /// URL immagine illustrativa
  fileUrl      String? /// URL file caricato (PDF o altro documento)
  order        Int     @default(0) /// Ordine di visualizzazione
  appliesToAll Boolean @default(true) /// Se true, si applica a tutte le fasi
  isnew        Boolean @default(false) /// Se true, la guida è nuova
  productId    String  @db.Uuid
  product      Product @relation(fields: [productId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  /// Relazione many-to-many con AssemblyStage
  stages       GuideToAssemblyStage[]
  /// Guida step-by-step (strutturata). Se vuota, la guida può essere solo PDF/URL (legacy).
  steps        GuideStep[]
  /// Cache traduzioni (IT -> altre lingue) per mostrare le guide in base alla lingua utente.
  translations GuideTranslation[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([productId])
  @@schema("inventory")
}

/// Step della guida (supporta sotto-step tramite `parentId`).
/// Esempio: Step 2 (parentId = null), Step 2.2 (parentId = id dello step 2).
model GuideStep {
  id String @id @default(uuid()) @db.Uuid

  guideId String @db.Uuid
  guide   Guide  @relation(fields: [guideId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  /// Relazione ricorsiva per sotto-step (2.1, 2.2, ...)
  parentId String?     @db.Uuid
  parent   GuideStep?  @relation("GuideStepParent", fields: [parentId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  children GuideStep[] @relation("GuideStepParent")

  title       String
  description String? @db.Text
  order       Int     @default(0) /// Ordine tra i fratelli (stesso parentId)

  /// Media allegati al singolo step (immagini, file, video link)
  media        GuideStepMedia[]
  translations GuideStepTranslation[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([guideId])
  @@index([parentId])
  @@schema("inventory")
}

/// Tipo di media per uno step guida.
enum GuideStepMediaType {
  IMAGE
  FILE
  VIDEO

  @@schema("inventory")
}

/// Media per uno `GuideStep` (supporta più immagini e allegati con ordine).
model GuideStepMedia {
  id String @id @default(uuid()) @db.Uuid

  stepId String    @db.Uuid
  step   GuideStep @relation(fields: [stepId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  type    GuideStepMediaType @default(IMAGE)
  url     String             @db.Text
  caption String?            @db.Text
  order   Int                @default(0)

  translations GuideStepMediaTranslation[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([stepId])
  @@schema("inventory")
}

/// Cache traduzione per un `GuideStep` in una determinata lingua.
/// Nota: la sorgente è in italiano (`GuideStep.title` + `GuideStep.description`).
model GuideStepTranslation {
  id String @id @default(uuid()) @db.Uuid

  stepId String    @db.Uuid
  step   GuideStep @relation(fields: [stepId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  language   String @db.VarChar(10)
  sourceHash String @db.VarChar(64)

  translatedTitle       String  @db.Text
  translatedDescription String? @db.Text

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([stepId, language])
  @@index([stepId])
  @@index([language])
  @@schema("inventory")
}

/// Cache traduzione per la caption di un `GuideStepMedia`.
model GuideStepMediaTranslation {
  id String @id @default(uuid()) @db.Uuid

  mediaId String         @db.Uuid
  media   GuideStepMedia @relation(fields: [mediaId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  language   String @db.VarChar(10)
  sourceHash String @db.VarChar(64)

  translatedCaption String? @db.Text

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([mediaId, language])
  @@index([mediaId])
  @@index([language])
  @@schema("inventory")
}

/// Cache traduzione per una `Guide` in una determinata lingua.
/// Nota: la sorgente è in italiano (`Guide.title` + `Guide.description`).
/// Usiamo `sourceHash` per invalidare automaticamente la cache se cambiano i testi sorgente.
model GuideTranslation {
  id String @id @default(uuid()) @db.Uuid

  guideId String @db.Uuid
  guide   Guide  @relation(fields: [guideId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  /// Lingua target (es. "en", "bn"). Manteniamo stringa per poter aggiungere lingue senza migrazioni su enum.
  language String @db.VarChar(10)

  /// Hash (sha256 hex) del contenuto sorgente (italiano) usato per generare questa traduzione.
  sourceHash String @db.VarChar(64)

  /// Testi tradotti (cache su DB).
  translatedTitle       String  @db.Text
  translatedDescription String? @db.Text

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([guideId, language])
  @@index([guideId])
  @@index([language])
  @@schema("inventory")
}

/// Tabella di join per Guide e AssemblyStage (many-to-many)
model GuideToAssemblyStage {
  guideId         String @db.Uuid
  assemblyStageId String @db.Uuid

  guide         Guide         @relation(fields: [guideId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  assemblyStage AssemblyStage @relation(fields: [assemblyStageId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([guideId, assemblyStageId])
  @@index([assemblyStageId])
  @@schema("inventory")
}

/// Avviso di sicurezza/assemblaggio associato a un Product.
/// Puo essere associato a zero, uno o piu AssemblyStages tramite la tabella di join.
/// Se non ha stages associati, avviso si applica a tutto il prodotto.
model Warning {
  id           String          @id @default(uuid()) @db.Uuid
  type         WarningType     @default(OTHER)
  severity     WarningSeverity @default(MEDIUM)
  description  String          @db.Text
  imageUrl     String? /// URL immagine illustrativa
  order        Int             @default(0) /// Ordine di visualizzazione
  appliesToAll Boolean         @default(true) /// Se true, si applica a tutte le fasi
  isnew        Boolean         @default(false) /// Se true, l'avviso è nuovo
  productId    String          @db.Uuid
  product      Product         @relation(fields: [productId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  /// Relazione many-to-many con AssemblyStage
  stages       WarningToAssemblyStage[]
  /// Cache traduzioni (IT -> altre lingue) per mostrare i warning in base alla lingua utente.
  translations WarningTranslation[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([productId])
  @@index([severity])
  @@schema("inventory")
}

/// Cache traduzione per una `Warning` in una determinata lingua.
/// Nota: la sorgente è la descrizione in italiano (`Warning.description`).
/// Usiamo `sourceHash` per invalidare automaticamente la cache se cambia il testo sorgente.
model WarningTranslation {
  id String @id @default(uuid()) @db.Uuid

  warningId String  @db.Uuid
  warning   Warning @relation(fields: [warningId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  /// Lingua target (es. "en", "bn"). Manteniamo stringa per poter aggiungere lingue senza migrazioni su enum.
  language String @db.VarChar(10)

  /// Hash (sha256 hex) della descrizione sorgente (italiano) usata per generare questa traduzione.
  sourceHash String @db.VarChar(64)

  /// Testo tradotto (cache su DB).
  translatedDescription String @db.Text

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([warningId, language])
  @@index([warningId])
  @@index([language])
  @@schema("inventory")
}

/// Tabella di join per Warning e AssemblyStage (many-to-many)
model WarningToAssemblyStage {
  warningId       String @db.Uuid
  assemblyStageId String @db.Uuid

  warning       Warning       @relation(fields: [warningId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  assemblyStage AssemblyStage @relation(fields: [assemblyStageId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([warningId, assemblyStageId])
  @@index([assemblyStageId])
  @@schema("inventory")
}

/// Definisce una categoria per raggruppare gli 'Item'.
/// Utile per l'organizzazione e il filtraggio.
model Category {
  id                 String         @id @default(uuid()) @db.Uuid
  name               String
  associatedItemType ItemType
  items              Item[]
  odetteTypes        OdetteType[]
  warehouseRows      WarehouseRow[]

  /// Stampanti che preferiscono questa categoria materiale (solo per ItemType.MATERIAL)
  printerPreferences PrinterPreferredMaterialCategory[]

  /// Profili consumo energia (override) che fanno riferimento a questa categoria (solo per materiali).
  printerModelEnergyProfiles PrinterModelEnergyProfile[]
  /// Slice giornaliere energia che fanno riferimento a questa categoria (tipicamente per PRINT_RUN).
  printerEnergyDailySlices   PrinterEnergyDailySlice[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([name, associatedItemType])
  @@index([associatedItemType])
  @@index([name])
  @@schema("inventory")
}

/// Definisce un tipo di imballaggio per gli articoli (es. scatola, contenitore).
model PackagingType {
  id                 String         @id @default(uuid()) @db.Uuid
  name               String
  class              PackagingClass @default(PRIMARY)
  associatedItemType ItemType
  items              Item[]
  itemSpecs          ItemSpec[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([name, associatedItemType])
  @@index([associatedItemType])
  @@index([name])
  @@schema("inventory")
}

/// Definisce un colore per gli 'Item', con codice esadecimale opzionale.
model Color {
  id                 String   @id @default(uuid()) @db.Uuid
  name               String
  hexCode            String?
  associatedItemType ItemType
  items              Item[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([name, associatedItemType])
  @@index([associatedItemType])
  @@index([name])
  @@schema("inventory")
}

/// Definisce un marchio o brand per gli 'Item'.
model Brand {
  id                 String   @id @default(uuid()) @db.Uuid
  name               String
  associatedItemType ItemType
  items              Item[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([name, associatedItemType])
  @@index([associatedItemType])
  @@index([name])
  @@schema("inventory")
}

/// Definisce un peso standard per un articolo, utile per calcoli logistici.
model StandardWeight {
  id                 String   @id @default(uuid()) @db.Uuid
  weight             Decimal  @db.Decimal(12, 2)
  associatedItemType ItemType
  items              Item[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([associatedItemType])
  @@schema("inventory")
}

/// Modello per le macchine compatibili con i ricambi ('SPARE_PART').
model CompatibleMachine {
  id                 String   @id @default(uuid()) @db.Uuid
  name               String
  associatedItemType ItemType @default(SPARE_PART)
  spareParts         Item[]   @relation("SpareParts")

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([name, associatedItemType])
  @@index([name])
  @@index([associatedItemType])
  @@schema("inventory")
}

/// Tabella di join per associare un 'ProductItem' con i suoi imballaggi ('Item' di tipo 'PACKAGING').
model ProductToPackage {
  id String @id @default(uuid()) @db.Uuid

  productId       String  @db.Uuid
  itemSpecId      String  @db.Uuid
  skuId           String? @db.Uuid
  assemblyStageId String? @db.Uuid

  quantity Int @default(1)
  /// Ordine/precedenza nel packaging del prodotto (0 = prima scelta).
  priority Int @default(0)

  itemSpec      ItemSpec       @relation(fields: [itemSpecId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  product       Product        @relation("ProductPackages", fields: [productId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sku           Sku?           @relation(fields: [skuId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  assemblyStage AssemblyStage? @relation(fields: [assemblyStageId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  @@index([itemSpecId])
  @@index([skuId])
  @@index([assemblyStageId])
  @@schema("inventory")
}

/// Tabella di join per associare un 'ProductItem' con gli attrezzi ('Item' di tipo 'TOOL') necessari.
model ProductToTool {
  productId  String   @db.Uuid
  itemSpecId String   @db.Uuid
  itemSpec   ItemSpec @relation(fields: [itemSpecId], references: [id], onDelete: Restrict)
  product    Product  @relation("ProductTools", fields: [productId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([productId, itemSpecId])
  @@index([itemSpecId])
  @@schema("inventory")
}

/// Tabella di join per associare un 'ProductItem' con le utility ('Item' di tipo 'UTILITY') necessarie.
/// Le utility sono consumabili assegnati a una specifica fase di assemblaggio.
model ProductToUtility {
  id String @id @default(uuid()) @db.Uuid

  productId       String  @db.Uuid
  itemSpecId      String  @db.Uuid
  skuId           String? @db.Uuid
  assemblyStageId String? @db.Uuid /// Fase di assemblaggio a cui è assegnata la utility

  quantity Int @default(1)
  /// Ordine/precedenza nelle utility del prodotto (0 = prima scelta).
  priority Int @default(0)

  itemSpec      ItemSpec       @relation(fields: [itemSpecId], references: [id], onDelete: Restrict)
  product       Product        @relation("ProductUtilities", fields: [productId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  assemblyStage AssemblyStage? @relation(fields: [assemblyStageId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  sku           Sku?           @relation(fields: [skuId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([itemSpecId])
  @@index([assemblyStageId])
  @@index([skuId])
  @@schema("inventory")
}

/// Tabella di join per associare un 'ProductItem' con i suoi componenti ('Item' di tipo 'COMPONENT').
model ProductToComponent {
  id String @id @default(uuid()) @db.Uuid

  productId       String  @db.Uuid
  itemSpecId      String  @db.Uuid
  skuId           String? @db.Uuid
  assemblyStageId String? @db.Uuid

  quantity Int @default(1)
  /// Ordine/precedenza nei componenti del prodotto (0 = prima scelta).
  priority Int @default(0)

  itemSpec      ItemSpec       @relation(fields: [itemSpecId], references: [id], onDelete: Restrict)
  product       Product        @relation("ProductComponents", fields: [productId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sku           Sku?           @relation(fields: [skuId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  assemblyStage AssemblyStage? @relation(fields: [assemblyStageId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  @@index([itemSpecId])
  @@index([skuId])
  @@index([assemblyStageId])
  @@schema("inventory")
}

/// Tipi di articoli gestibili dall'inventario.
enum ItemType {
  MATERIAL
  PACKAGING
  COMPONENT
  ACCESSORY
  SPARE_PART
  TOOL
  UTILITY
  PRODUCT
  ODETTE

  @@schema("inventory")
}

/// Tipo di fase di assemblaggio.
enum AssemblyStageType {
  /// DEPRECATO: non usare. La disponibilità "da parti" viene calcolata virtualmente.
  RAW
  ASSEMBLED // sotto-assieme assemblato
  FIRST_STAGE // prima fase di assemblaggio prodotto con packaging primario
  SECOND_STAGE // prodotto finito con packaging primario e secondario
  OTHER // altro

  @@schema("inventory")
}

/// Tipi di imballaggio: primario (a contatto col prodotto), secondario (scatola esterna), altro.
enum PackagingClass {
  PRIMARY
  SECONDARY
  OTHERS

  @@schema("inventory")
}

/// Tipo di avviso per il modello Warning
enum WarningType {
  SAFETY /// Sicurezza
  HANDLING /// Maneggiamento
  ASSEMBLY /// Assemblaggio
  QUALITY /// Qualità
  OTHER /// Altro

  @@schema("inventory")
}

/// Gravità dell'avviso per il modello Warning
enum WarningSeverity {
  LOW /// Bassa
  MEDIUM /// Media
  HIGH /// Alta
  CRITICAL /// Critica

  @@schema("inventory")
}

/// Origine di una `ProductPart`:
/// - MAKE: prodotta internamente (print farm / lavorazione interna)
/// - BUY: acquistata da terzi e poi assemblata internamente
enum PartSourceType {
  MAKE
  BUY

  @@schema("inventory")
}
