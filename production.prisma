/// Rappresenta un ordine di produzione per un 'Product'.
/// Specifica la quantità da produrre e traccia lo stato di avanzamento.
/// Genera N ProductionJob (uno per ogni parte da stampare).
/// Ora collegato a uno SKU specifico per determinare il canale (FBA/FBM).
model ProductOrder {
  id        String @id @default(uuid()) @db.Uuid
  /// Progressivo numerico leggibile (BIGINT Postgres) per uso umano/reportistica.
  /// Nota: lasciamo `id` UUID come PK per non rompere relazioni/migrazioni; questo è solo un numero sequenziale.
  number    BigInt @unique @default(autoincrement()) @db.BigInt
  productId String @db.Uuid

  skuId             String?          @db.Uuid /// SKU di destinazione - determina il canale (FBA/FBM)
  quantityToProduce Int /// Quantità totale di prodotti finiti da produrre
  quantityProduced  Int              @default(0) /// Quantità di prodotti finiti completati
  eta               DateTime?        @db.Timestamptz(6)
  finishedAt        DateTime?        @db.Timestamptz(6)
  cost              Decimal?         @db.Decimal(12, 2)
  priority          Int              @default(1) /// 1=low, 2=medium, 3=high, 4=critical
  productionStatus  ProductionStatus @default(READY_TO_PRODUCE)
  status            OrderStatus      @default(TO_ORDER)
  createdAt         DateTime         @default(now()) @db.Timestamptz(6)
  updatedAt         DateTime         @default(now()) @updatedAt @db.Timestamptz(6)

  product Product @relation(fields: [productId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  sku     Sku?    @relation(fields: [skuId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  producedByUserId Int?
  producedBy       User? @relation(fields: [producedByUserId], references: [id], onDelete: SetNull)

  /// M2M esplicite con quantità per tracciare consumo item e parti prodotte
  items ProductOrderItem[]
  parts ProductOrderProductPart[]

  assemblyOrderId String?        @db.Uuid
  assemblyOrder   AssemblyOrder? @relation("AssemblyOrderToProductItemOrder", fields: [assemblyOrderId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  lots InventoryLot[]

  /// Job di stampa 3D generati da questo ordine (uno per parte)
  productionJobs ProductionJob[] @relation("ProductOrderJobs")
  movements      Movement[]

  @@index([skuId])
  @@index([assemblyOrderId])
  @@index([producedByUserId])
  @@index([productionStatus])
  @@index([priority])
  @@schema("inventory")
}

/// Riga di consumo di un Item (materia prima/componente) per un ordine di produzione (ProductItemOrder).
/// MIGLIORIA: M2M esplicita ProductItemOrder ↔ Item con quantità
/// Perché: evitare M2M implicite e aggiungere metadata/indici.
model ProductOrderItem {
  productOrderId String @db.Uuid
  itemId         String @db.Uuid
  quantity       Int    @default(1)

  productOrder ProductOrder @relation(fields: [productOrderId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  item         Item         @relation(fields: [itemId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  @@id([productOrderId, itemId])
  @@index([itemId])
  @@schema("inventory")
}

/// Riga di consumo di un sotto-assieme/parte (ProductPart) per un ordine di produzione.
/// Traccia quante parti sono necessarie e quante sono state prodotte.
model ProductOrderProductPart {
  productOrderId   String @db.Uuid
  productPartId    String @db.Uuid
  quantity         Int    @default(1) /// Quantità di parti necessarie per l'ordine
  quantityProduced Int    @default(0) /// Quantità di parti effettivamente prodotte

  productOrder ProductOrder @relation(fields: [productOrderId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  productPart  ProductPart  @relation(fields: [productPartId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  @@id([productOrderId, productPartId])
  @@index([productPartId])
  @@schema("inventory")
}

/// Rappresenta un ordine di assemblaggio per un prodotto in base allo SKU.
/// Lo SKU determina il canale (FBA/FBM) e le parti necessarie per l'assemblaggio.
model AssemblyOrder {
  id                 String @id @default(uuid()) @db.Uuid
  /// Progressivo numerico leggibile (BIGINT Postgres) per uso umano/reportistica.
  /// Nota: lasciamo `id` UUID come PK per non rompere relazioni/migrazioni; questo è solo un numero sequenziale.
  number             BigInt @unique @default(autoincrement()) @db.BigInt
  productId          String @db.Uuid
  skuId              String @db.Uuid // SKU determina canale e parti necessarie
  quantityToAssemble Int    @default(0)
  quantityAssembled  Int    @default(0)
  quantityScrapped   Int    @default(0)

  startedAt  DateTime?      @db.Timestamptz(6)
  finishedAt DateTime?      @db.Timestamptz(6)
  priority   Int            @default(0) // 0: Bassa, 1: Media, 2: Alta
  status     AssemblyStatus @default(READY_TO_ASSEMBLE)
  createdAt  DateTime       @default(now()) @db.Timestamptz(6)
  updatedAt  DateTime       @default(now()) @updatedAt @db.Timestamptz(6)

  product           Product             @relation(fields: [productId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  sku               Sku                 @relation(fields: [skuId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  assembledByUserId Int?
  assembledBy       User?               @relation(fields: [assembledByUserId], references: [id], onDelete: SetNull)
  productOrders     ProductOrder[]      @relation("AssemblyOrderToProductItemOrder")
  OdetteReservation OdetteReservation[]
  /// Contenuti odette legati a questo ordine (quando valorizzato su OdetteContent).
  odetteContents    OdetteContent[]
  lots              InventoryLot[]
  /// Movimenti inventario collegati a questo ordine di assemblaggio (audit).
  movements         Movement[]
  operations        AssemblyOperation[]

  @@index([assembledByUserId])
  @@index([skuId])
  @@schema("inventory")
}

model AssemblyOperation {
  id String @id @default(uuid()) @db.Uuid

  assemblyOrderId String        @db.Uuid
  assemblyOrder   AssemblyOrder @relation(fields: [assemblyOrderId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  type AssemblyOperationType

  assemblyStageId String?        @db.Uuid
  assemblyStage   AssemblyStage? @relation(fields: [assemblyStageId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  operatorId Int
  operator   User @relation(fields: [operatorId], references: [id])

  // --- TEMPI ---
  startedAt       DateTime  @default(now()) @db.Timestamptz(6)
  endedAt         DateTime? @db.Timestamptz(6)
  durationSeconds Int? // Calcolato alla fine (utile per costo manodopera)

  // --- QUANTITÀ DELLA SESSIONE ---
  quantityInput    Int @default(0) // Quanti pezzi stavo lavorando in questa sessione?
  quantityProduced Int @default(0) // Quanti pezzi BUONI ho finito in questa sessione?
  quantityScrapped Int @default(0) // Quanti pezzi ho SCARTATO in questa sessione?

  // --- TRACCIABILITÀ ---
  lotId String?       @db.Uuid
  lot   InventoryLot? @relation(fields: [lotId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  notes    String?
  metadata Json? // Per info extra (es. motivo scarto, boxId, shelfId)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([assemblyOrderId])
  @@index([operatorId])
  @@index([lotId])
  @@index([assemblyStageId])
  @@schema("inventory")
}

/// Lotto/commessa di produzione (es. job di stampa 3D).
model ProductionLot {
  id            String         @id @default(uuid()) @db.Uuid
  /// Progressivo numerico leggibile (BIGINT Postgres) per uso umano/reportistica.
  /// Nota: lasciamo `id` UUID come PK; questo è solo un numero sequenziale (compatibile Supabase).
  number        BigInt         @unique @default(autoincrement()) @db.BigInt
  code          String         @unique /// es. JOB-2025-10-001
  printerId     String? /// opzionale: id macchina/stampante
  material      String? /// es. PLA, ABS...
  color         String? /// es. HEX/RGB o descrizione
  startedAt     DateTime?      @db.Timestamptz(6)
  finishedAt    DateTime?      @db.Timestamptz(6)
  note          String?
  /// Lotti di inventario (prodotti finiti o semilavorati) generati da questo lotto di produzione.
  inventoryLots InventoryLot[]

  /// Righe che fanno riferimento a questo lotto
  odetteContents  OdetteContent[]
  /// Odettes riservate a questo lotto
  reservedOdettes Odette[]

  // Relazione Print Farm
  productionJobs  ProductionJob[]
  /// Operazioni di raccolta pezzi associate a questo lotto
  printerHarvests PrinterHarvest[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@schema("inventory")
}

/// Contenitore fisico (cassetta) dove si accumulano pezzi/parti/prodotti.
model Odette {
  id String @id @default(uuid()) @db.Uuid

  /// Codice leggibile e barcode per scansione rapida
  code    String  @unique
  barcode String? @unique

  /// Stato operativo della odette
  status OdetteStatus @default(EMPTY)

  /// Uso logico dell'odette: serve a separare odette "per prodotti" da odette "per item"
  /// ed evitare che la stessa odette venga usata per scopi diversi.
  /// Nota: l'app dovrebbe garantire coerenza con OdetteType.purpose quando typeId è valorizzato.
  purpose OdettePurpose @default(PRODUCTS)

  /// Blocco stage: appena entra la prima riga si "fissa" lo stage;
  /// serve a impedire mix di stage diversi nella stessa odette.
  lockedStage AssemblyStageType?

  /// Tipo di odette (dimensioni/capacità)
  typeId String?     @db.Uuid
  type   OdetteType? @relation(fields: [typeId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Posizione attuale in magazzino
  locationId String?            @db.Uuid
  location   WarehouseLocation? @relation(fields: [locationId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Contenuti correnti (righe)
  contents OdetteContent[]

  /// Prenotazioni (parziali) verso AssemblyOrder (per pezzi specifici)
  reservations OdetteReservation[]

  /// Storico spostamenti dell'odette tra location
  moves OdetteMove[]

  /// Log di pulizia/svuotamento
  cleaningLogs OdetteCleaningLog[]

  /// Metadati prenotazione contenitore (per job di produzione)
  reservedLotId String?        @db.Uuid
  reservedLot   ProductionLot? @relation(fields: [reservedLotId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  reservedAt    DateTime?      @db.Timestamptz(6)

  // Relazione Print Farm
  productionJobs ProductionJob[]

  /// Operazioni di raccolta pezzi in questa odette
  printerHarvests PrinterHarvest[]

  createdAt DateTime   @default(now()) @db.Timestamptz(6)
  updatedAt DateTime   @default(now()) @updatedAt @db.Timestamptz(6)
  Movement  Movement[]

  @@index([status])
  @@index([lockedStage])
  @@index([locationId])
  @@index([status, typeId, locationId])
  @@index([reservedLotId])
  @@schema("inventory")
}

/// Riga di contenuto in una odette (quantità per entità).
model OdetteContent {
  id       String @id @default(uuid()) @db.Uuid
  odetteId String @db.Uuid
  odette   Odette @relation(fields: [odetteId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  // Polimorfismo: esattamente UNA FK deve essere valorizzata.
  // Regola di business consigliata:
  // - Se odette.purpose = ITEMS -> usa itemId
  // - Se odette.purpose = PRODUCTS -> usa PartId (e NON itemId)
  itemId String? @db.Uuid
  item   Item?   @relation(fields: [itemId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  PartId String?      @db.Uuid
  Part   ProductPart? @relation(fields: [PartId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  /// Stage “logico” del contenuto (coerente con Odette.lockedStage)
  assemblyStageId String?        @db.Uuid
  assemblyStage   AssemblyStage? @relation(fields: [assemblyStageId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Ordine di assemblaggio a cui appartengono questi pezzi (quando il contenuto è legato a un task specifico).
  /// Serve a evitare ambiguità quando la stessa odette contiene pezzi dello stesso SKU/stage per ordini diversi.
  assemblyOrderId String?        @db.Uuid
  assemblyOrder   AssemblyOrder? @relation(fields: [assemblyOrderId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Quantità disponibile fisicamente nella odette (non prenotata)
  quantity Int

  /// Opzionale: associazione diretta a uno SKU (FBA/FBM) per distinguere i pezzi già allocati
  skuId String? @db.Uuid
  sku   Sku?    @relation(fields: [skuId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Facoltativo: lotto/commessa di produzione (vedi ProductionLot)
  lotId String?        @db.Uuid
  lot   ProductionLot? @relation(fields: [lotId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  inventoryLotId String?       @db.Uuid
  inventoryLot   InventoryLot? @relation(fields: [inventoryLotId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  createdAt         DateTime            @default(now()) @db.Timestamptz(6)
  updatedAt         DateTime            @default(now()) @updatedAt @db.Timestamptz(6)
  OdetteReservation OdetteReservation[]

  @@index([odetteId])
  @@index([itemId])
  @@index([PartId])
  @@index([assemblyStageId])
  @@index([assemblyOrderId])
  @@index([inventoryLotId])
  @@index([skuId])
  @@index([odetteId, skuId, assemblyStageId, assemblyOrderId])
  @@schema("inventory")
}

/// Prenotazione parziale di quantità da una riga contenuto verso un AssemblyOrder.
model OdetteReservation {
  id       String @id @default(uuid()) @db.Uuid
  odetteId String @db.Uuid
  odette   Odette @relation(fields: [odetteId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  /// Prenoto da UNA specifica riga (così traccio item vs itemPart vs productItem)
  odetteContentId String        @db.Uuid
  odetteContent   OdetteContent @relation(fields: [odetteContentId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  assemblyOrderId String?        @db.Uuid
  assemblyOrder   AssemblyOrder? @relation(fields: [assemblyOrderId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Se vuoi prenotare per canale/sku (FBA/FBM) anche in fase di WIP
  channel InventoryChannel?
  skuId   String?           @db.Uuid
  sku     Sku?              @relation(fields: [skuId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Quantità prenotata (≤ OdetteContent.quantity al momento della prenotazione)
  reservedQty Int

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([odetteId])
  @@index([odetteContentId])
  @@index([assemblyOrderId])
  @@index([channel])
  @@index([skuId])
  @@schema("inventory")
}

/// Storico movimenti dell’odette tra location fisiche.
model OdetteMove {
  id       String @id @default(uuid()) @db.Uuid
  odetteId String @db.Uuid
  odette   Odette @relation(fields: [odetteId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  fromLocationId String?            @db.Uuid
  toLocationId   String?            @db.Uuid
  fromLocation   WarehouseLocation? @relation("OdetteMoveFrom", fields: [fromLocationId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  toLocation     WarehouseLocation? @relation("OdetteMoveTo", fields: [toLocationId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  movedAt     DateTime @default(now()) @db.Timestamptz(6)
  movedByUser Int? /// opzionale: chi ha spostato (User.id)
  user        User?    @relation(fields: [movedByUser], references: [id], onDelete: SetNull)

  note String?

  @@index([odetteId])
  @@index([fromLocationId])
  @@index([toLocationId])
  @@index([movedByUser])
  @@schema("inventory")
}

/// Log di pulizia/svuotamento dell’odette (audit).
model OdetteCleaningLog {
  id       String @id @default(uuid()) @db.Uuid
  odetteId String @db.Uuid
  odette   Odette @relation(fields: [odetteId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  note String?

  at       DateTime @default(now()) @db.Timestamptz(6)
  byUserId Int?
  byUser   User?    @relation(fields: [byUserId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now()) @db.Timestamptz(6)

  @@index([odetteId])
  @@index([byUserId])
  @@schema("inventory")
}

/// Definisce un tipo di odette con dimensioni/capacità e vincoli d'uso.
model OdetteType {
  id                String        @id @default(uuid()) @db.Uuid
  name              String        @unique
  code              String?       @unique
  imageUrl          String?
  /// Scopo/uso del tipo di odette (es. "PRODOTTI" vs "ITEM").
  /// Serve a impedire l'utilizzo improprio: un tipo "PRODOTTI" non dovrebbe accettare contenuti item e viceversa.
  purpose           OdettePurpose @default(PRODUCTS)
  /// Categoria dimensionale (es. S, M, L) per visualizzazione/badge
  categoryId        String?       @db.Uuid
  category          Category?     @relation(fields: [categoryId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  /// Dimensioni esterne (mm)
  dimensionsId      String?       @db.Uuid
  dimensions        Dimensions?   @relation(fields: [dimensionsId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  /// Volume interno utile (cm^3)
  internalVolumeCm3 Int?
  /// Capacità massima di peso (kg)
  maxWeightKg       Decimal?      @db.Decimal(10, 2)
  /// Numero massimo indicativo di pezzi contenibili
  maxPieces         Int?
  stackable         Boolean       @default(true)
  /// Odettes appartenenti a questo tipo
  odettes           Odette[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([purpose])
  @@index([categoryId])
  @@schema("inventory")
}

/// Preferenze di location per le odette in base allo stato (vuota/piena)
model OdetteLocationPreference {
  id         String             @id @default(uuid()) @db.Uuid
  locationId String             @db.Uuid
  kind       OdetteLocationKind

  location WarehouseLocation @relation(fields: [locationId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([locationId, kind])
  @@index([kind])
  @@schema("inventory")
}

enum AssemblyOperationType {
  PICKING // Collezione parti
  ASSEMBLY // Assemblaggio vero e proprio
  PRIMARY_PACKAGING // Impacchettamento primario
  SECONDARY_PACKAGING // Impacchettamento secondario
  ALLOCATION // Allocamento (Scaffale o Scatola FBA)

  @@schema("inventory")
}

/// Stato di un ordine di produzione.
enum ProductionStatus {
  READY_TO_PRODUCE
  PRODUCED
  PRODUCING
  CANCELLED
  NEED_SUPPLIES

  @@schema("inventory")
}

/// Stato di un ordine di assemblaggio.
enum AssemblyStatus {
  READY_TO_ASSEMBLE
  NEEDS_PARTS // Mancano parti per completare l'assemblaggio
  ASSEMBLY_STARTED
  PARTIALLY_COMPLETED
  ASSEMBLY_COMPLETED
  ON_HOLD
  CANCELLED

  @@schema("inventory")
}

/// Stato operativo dell’odette
enum OdetteStatus {
  IN_USE /// contiene pezzi e può essere movimentata
  RESERVED /// prenotata per essere riempita a breve
  EMPTY /// svuotata ma non ancora pulita e pronta per essere usata
  OUT_OF_SERVICE /// opzionale: rotta/manutenzione
  FULL /// piena
  @@schema("inventory")
}

/// Scopo/uso logico dell'odette.
/// Indica la destinazione d'uso preferita del tipo di odette:
/// - PRODUCTS: uso generico prodotti (legacy, retrocompatibile)
/// - ITEMS: item / magazzino materie prime
/// - ASSEMBLY_PARTS: parti in area assemblaggio
/// - PRODUCT_PARTS: parti prodotto (ItemPart stampate/semilavorati)
/// - FINISHED_PRODUCTS: prodotti finiti
/// - MIXED: uso misto / multiuso
enum OdettePurpose {
  PRODUCTS
  ITEMS
  ASSEMBLY_PARTS
  PRODUCT_PARTS
  FINISHED_PRODUCTS
  MIXED

  @@schema("inventory")
}

/// Ruolo/uso di una location per il flusso odette.
/// Nota: la "pienezza" è uno stato dell'odette (e/o derivabile dai contenuti),
/// mentre questa enum rappresenta la ZONA fisica/logistica.
enum OdetteLocationKind {
  EMPTY_STORAGE
  PRINT_FARM_QUEUE
  ASSEMBLY_BUFFER
  FULL_STORAGE

  @@schema("inventory")
}

enum OrderStatus {
  TO_ORDER
  ORDERED
  RECEIVED

  @@schema("inventory")
}
