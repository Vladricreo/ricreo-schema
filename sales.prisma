/// SKU vendibile per un ProductItem.
/// Separa stock, movimenti e spedizioni per canale (FBM/FBA) e marketplace.
model Sku {
  id          String           @id @default(uuid()) @db.Uuid
  productId   String           @db.Uuid
  code        String           @unique
  channel     InventoryChannel /// FBM/FBA (UNALLOCATED sconsigliato per SKU vendibili)
  marketplace Marketplace      @default(AMAZON_FBA)
  /// Nota: l'eleggibilità per FBA/FBM rispetto al packaging finale
  /// viene gestita applicativamente (AssemblyStage non è stato toccato).
  isDefault   Boolean          @default(false)

  isActive                 Boolean            @default(true)
  /// Se true, questo SKU NON deve essere stoccato/riassortito automaticamente.
  /// Effetto: la generazione automatica di `ProductOrder` deve ignorarlo.
  doNotStock               Boolean            @default(false)
  minStock                 Int                @default(0)
  currentStock             Int                @default(0)
  dimensionsId             String?            @db.Uuid
  dimensions               Dimensions?        @relation(fields: [dimensionsId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  requiresSecondaryPackage Boolean            @default(false)
  finalStageType           AssemblyStageType  @default(SECOND_STAGE) // stato del prodotto effettivamente finito se ha bisogno del packaging primario o secondario di default: prodotto finito con packaging primario e secondario
  locationId               String?            @db.Uuid
  location                 WarehouseLocation? @relation(fields: [locationId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  ean                      String?
  asin                     String?
  createdAt                DateTime           @default(now()) @db.Timestamptz(6)
  updatedAt                DateTime           @default(now()) @updatedAt @db.Timestamptz(6)

  /// Allocazioni multi-location per questo SKU (quantità per slot).
  warehouseSkuAllocations WarehouseSkuAllocation[]

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  amazonProduct       AmazonProduct?
  /// Righe ordini Amazon collegate a questo SKU (collegamento opzionale da `AmazonOrderItem.skuId`).
  amazonOrderItems    AmazonOrderItem[]
  shipmentLines       ShipmentLine[]
  movements           Movement[]
  finishedAllocations FinishedAllocation[]
  OdetteReservation   OdetteReservation[]
  OdetteContent       OdetteContent[]
  assemblyOrders      AssemblyOrder[]
  productOrders       ProductOrder[]
  projectFiles        ProjectThreeMFFile[] @relation("ProjectRelatedSku")

  productPackages   ProductToPackage[]
  productComponents ProductToComponent[]
  productUtilities  ProductToUtility[]

  @@index([productId, channel, marketplace])
  @@index([locationId])
  @@schema("inventory")
}

/// Rappresenta un prodotto gestito tramite Amazon FBA (Fulfillment by Amazon).
/// Traccia le quantità, lo stato dell'annuncio e le previsioni di vendita.
model AmazonProduct {
  id                String             @id @default(uuid()) @db.Uuid
  productItemId     String?            @unique @db.Uuid
  fulfillmentType   FulfillmentType    @default(FBA)
  listingStatus     ListingStatus      @default(ACTIVE)
  quantityTotal     Int                @default(0)
  quantityInbound   Int                @default(0)
  quantityTransfer  Int                @default(0)
  quantityAvailable Int                @default(0)
  quantityReserved  Int                @default(0)
  inboundShipment   Boolean            @default(false)
  price             Decimal?           @db.Decimal(12, 2)
  salesVelocity     Decimal?           @db.Decimal(12, 2)
  stockDays         Int?
  restockDate       DateTime?          @db.Timestamptz(6)
  restockAction     RestockAction?
  optimalLotSize    Int?
  dimensionsId      String?            @db.Uuid
  dimensions        Dimensions?        @relation(fields: [dimensionsId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  weight            Decimal            @default(0) @db.Decimal(12, 2) /// prima: Float
  orderStatus       AmazonOrderStatus? @default(TO_ORDER)
  createdAt         DateTime           @default(now()) @db.Timestamptz(6)
  updatedAt         DateTime           @default(now()) @updatedAt @db.Timestamptz(6)
  /// MIGLIORIA: collegato a uno SKU FBA specifico (per marketplace)
  skuId             String?            @unique @db.Uuid
  sku               Sku?               @relation(fields: [skuId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  product           Product?           @relation(fields: [productItemId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  salesData         AmazonSalesData[]
  /// Righe ordini Amazon collegate a questo AmazonProduct (collegamento opzionale da `AmazonOrderItem.amazonProductId`).
  amazonOrderItems  AmazonOrderItem[]

  @@index([productItemId])
  @@index([skuId])
  @@schema("inventory")
}

/// Registra i dati di vendita giornalieri per un prodotto su Amazon.
model AmazonSalesData {
  id               String        @id @default(uuid()) @db.Uuid
  fbaProductId     String        @db.Uuid
  date             DateTime      @db.Date
  unitsSold        Int
  asin             String
  sku              String
  amazonOrderId    String?
  fbaProduct       AmazonProduct @relation(fields: [fbaProductId], references: [id])
  /// Chiave idempotente per upsert giornaliero (es. "<SKU>-<YYYY-MM-DD>").
  /// La rendiamo NOT NULL così non esistono righe "anonime" difficili da deduplicare.
  uniqueIdentifier String        @unique

  /// Vincolo forte: al massimo una riga al giorno per uno stesso prodotto FBA.
  @@unique([fbaProductId, date])
  @@index([fbaProductId])
  @@index([amazonOrderId])
  @@schema("inventory")
}

/// Testata ordine Amazon (dati non-PII).
/// Obiettivo: conservare uno storico ordini ricostruibile e idempotente (upsert).
model AmazonOrder {
  id String @id @default(uuid()) @db.Uuid

  /// ID ordine Amazon (es. "123-1234567-1234567").
  amazonOrderId   String
  /// ID ordine “merchant” (se presente nel report).
  merchantOrderId String?
  /// Marketplace su cui l'ordine è stato effettuato (es. "APJ6JRA9NG5V4" per IT).
  marketplaceId   String

  purchaseDate       DateTime? @db.Timestamptz(6)
  lastUpdatedDate    DateTime? @db.Timestamptz(6)
  orderStatus        String?
  fulfillmentChannel String? /// AFN (FBA) / MFN

  salesChannel     String?
  orderChannel     String?
  shipServiceLevel String?
  /// Numero totale item dell'ordine (colonna `number-of-items`).
  numberOfItems    Int?

  /// Destinazione spedizione (attenzione: dati potenzialmente sensibili).
  /// Conserviamo dati utili per analytics senza dettagli completi:
  /// - `shipPostalCode` è consigliato salvarlo in forma mascherata lato applicativo.
  shipCity       String?
  shipState      String?
  shipPostalCode String?
  shipCountry    String?

  /// Quantità totale ordinata (somma delle righe) per questo ordine.
  /// Nota: è derivabile da `AmazonOrderItem.quantity`, ma salvarla qui evita join per dashboard/report veloci.
  totalQuantity Int?

  promotionIds                String?
  isBusinessOrder             Boolean? @default(false)
  priceDesignation            String?
  buyerTaxRegistrationCountry String?
  buyerTaxRegistrationType    String?
  isAmazonInvoiced            Boolean?
  isIba                       Boolean?
  iossNumber                  String?
  orderInvoiceType            String?
  currency                    String?

  items AmazonOrderItem[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([amazonOrderId, marketplaceId])
  @@index([purchaseDate])
  @@index([orderStatus])
  @@schema("inventory")
}

/// Riga ordine Amazon (line item) - dati non-PII.
/// Nota: scegliamo una chiave `lineKey` per deduplicare anche se il report non fornisce sempre un ID riga.
model AmazonOrderItem {
  id String @id @default(uuid()) @db.Uuid

  orderId String      @db.Uuid
  order   AmazonOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)

  /// Chiave idempotente per la riga (es. "<amazonOrderId>-<orderItemId>" oppure fallback).
  lineKey String @unique

  /// Se disponibile dal report.
  orderItemId String?

  sku  String?
  asin String?

  /// Collegamenti opzionali al modello locale.
  skuId           String?        @db.Uuid
  skuRef          Sku?           @relation(fields: [skuId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  amazonProductId String?        @db.Uuid
  amazonProduct   AmazonProduct? @relation(fields: [amazonProductId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  quantity Int?

  itemPrice                 Decimal? @db.Decimal(12, 2)
  itemTax                   Decimal? @db.Decimal(12, 2)
  shippingPrice             Decimal? @db.Decimal(12, 2)
  shippingTax               Decimal? @db.Decimal(12, 2)
  giftWrapPrice             Decimal? @db.Decimal(12, 2)
  giftWrapTax               Decimal? @db.Decimal(12, 2)
  itemPromotionDiscount     Decimal? @db.Decimal(12, 2)
  shipPromotionDiscount     Decimal? @db.Decimal(12, 2)
  vatExclusiveItemPrice     Decimal? @db.Decimal(12, 2)
  vatExclusiveShippingPrice Decimal? @db.Decimal(12, 2)
  vatExclusiveGiftwrapPrice Decimal? @db.Decimal(12, 2)

  /// Campi descrittivi del report (non PII).
  productName String?
  itemStatus  String?

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([orderId])
  @@index([sku])
  @@index([asin])
  @@index([skuId])
  @@index([amazonProductId])
  @@schema("inventory")
}

/// Elenco degli ASIN che vanno ignorati durante il controllo/import da Amazon.
model AmazonIgnoredAsin {
  asin      String   @id
  note      String?
  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([createdAt])
  @@schema("inventory")
}

/// Modello per una spedizione, che può contenere un 'ProductItem' o essere legata a un 'Movement'.
/// Traccia informazioni come corriere, tracking e stato dell'etichetta.
model Shipment {
  id               String              @id @default(uuid()) @db.Uuid
  /// Progressivo numerico leggibile (BIGINT Postgres) per uso umano/reportistica.
  /// Nota: lasciamo `id` UUID come PK per non rompere relazioni/migrazioni; questo è solo un numero sequenziale.
  number           BigInt              @unique @default(autoincrement()) @db.BigInt
  movementId       String?             @db.Uuid
  /// Relazione al movimento.
  movement         Movement?           @relation(fields: [movementId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  productId        String?             @db.Uuid
  product          Product?            @relation(fields: [productId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  lines            ShipmentLine[]
  orderedAt        DateTime            @db.Timestamptz(6)
  shippedAt        DateTime?           @db.Timestamptz(6)
  /// Timestamp interno: quando l'etichetta è stata stampata dalla nostra app (CUPS).
  /// Serve per distinguere "stampato lato corriere" vs "stampato da noi".
  printedAt        DateTime?           @db.Timestamptz(6)
  courier          String?
  labelUrl         String?
  isShipped        Boolean             @default(false)
  orderNumber      String?
  recipientCountry String?
  recipientName    String?
  trackingNumber   String?
  trackingUrl      String?
  labelStatus      ShipmentLabelStatus @default(PENDING)
  shipmentType     ShipmentType        @default(STANDARD)
  createdAt        DateTime            @default(now()) @db.Timestamptz(6)
  updatedAt        DateTime            @default(now()) @updatedAt @db.Timestamptz(6)
  fullAddress      String?
  notes            String?

  @@index([productId])
  @@index([movementId])
  @@schema("inventory")
}

/// Riga di spedizione per uno specifico SKU.
/// Può essere collegata a un InventoryLot per tracciare il lotto fisico spedito al cliente.
model ShipmentLine {
  id         String  @id @default(uuid()) @db.Uuid
  shipmentId String  @db.Uuid
  /// FK verso Sku. Può essere NULL quando arriva uno SKU sconosciuto dal corriere:
  /// in quel caso salviamo comunque la riga usando `skuCodeSnapshot` per mostrarla come "non collegata".
  skuId      String? @db.Uuid
  quantity   Int     @default(1)

  /// MIGLIORIA: snapshot testuale dello SKU per documenti/archivio
  skuCodeSnapshot String?

  lotId String?       @db.Uuid
  lot   InventoryLot? @relation(fields: [lotId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  shipment Shipment @relation(fields: [shipmentId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sku      Sku?     @relation(fields: [skuId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([shipmentId])
  @@index([skuId])
  @@index([lotId])
  @@schema("inventory")
}

/// Tipo di fulfillment (logistica) per un prodotto.
enum FulfillmentType {
  FBA // Gestito da Amazon
  FBM // Gestito dal venditore
  OTHER // Altro

  @@schema("inventory")
}

/// Stato di un annuncio di prodotto su Amazon.
enum ListingStatus {
  ACTIVE
  INACTIVE
  INCOMPLETE

  @@schema("inventory")
}

/// Azione di restock suggerita per i prodotti Amazon.
enum RestockAction {
  NOW // Riordina ora
  SOON // Riordina a breve
  NO // Non riordinare

  @@schema("inventory")
}

/// Stato di un ordine interno relativo ad Amazon.
enum AmazonOrderStatus {
  TO_ORDER
  PROCESSING
  PRODUCED
  SHIPPED

  @@schema("inventory")
}

/// Stato dell'etichetta di spedizione.
enum ShipmentLabelStatus {
  PENDING
  GENERATED
  PRINTED
  CANCELLED

  @@schema("inventory")
}

/// Tipo di spedizione (es. standard, Prime per clienti business).
enum ShipmentType {
  PRIME
  BUSINESS
  STANDARD

  @@schema("inventory")
}

/// Perché: uno stesso ProductItem può avere più SKU per mercati diversi.
enum Marketplace {
  GENERIC
  AMAZON_FBA
  AMAZON_FBM
  EBAY
  ETSY

  @@schema("inventory")
}
