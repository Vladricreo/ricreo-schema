/// File di progetto 3MF per la stampa 3D.
/// Include informazioni sul file, parametri di stampa, materiali usati e versionamento.
model ProjectThreeMFFile {
  id                       String   @id @default(uuid()) @db.Uuid
  filename                 String
  filepath                 String
  filesize                 Decimal  @db.Decimal(12, 3)
  projectName              String
  skus                     Sku[]    @relation("ProjectRelatedSku")
  imageUrl                 String   @default("")
  estimatedDurationMinutes Int // tempo stimato in minuti
  compatiblePrinters       String[] // nomi stampanti compatibili
  zHeight                  Decimal  @db.Decimal(12, 2) // altezza modello in mm
  nozzleDiameter           Decimal  @db.Decimal(4, 2) // diametro ugello in mm
  partCount                Int // numero di parti nel plate
  totalLayers              Int // numero di strati
  totalFilamentWeight      Decimal? @db.Decimal(12, 2) // peso totale filamento usato in grammi
  plateNumber              Int      @default(1) // Numero del plate (index) per il comando di stampa

  /// Metadati estratti da `Metadata/slice_info.config` (Bambu Studio)
  printerModelId String?  // es. "C12"
  supportsUsed   Boolean  @default(false)
  objectCount    Int      @default(0) // numero <object skipped="false" />
  /// Oggetti nel plate (per skip/selezione oggetti singoli in stampa)
  /// JSON array: [{ identifyId: number, name: string, skipped: boolean }]
  sliceObjects   Json?

  /// Percentuale di riempimento del piano (es. 0.70 = 70%)
  /// Usata per stimare l'area delle parti quando non conosciamo le dimensioni esatte
  plateFillPercentage Decimal @default(0.70) @db.Decimal(3, 2)

  // Versionamento
  version   Int        @default(1)
  status    FileStatus @default(DRAFT)
  changeLog String? // Es. "Aumentato riempimento al 20%"

  // Self-relation per tracciare la storia delle versioni (v2 -> v1)
  previousVersionId String?             @unique @db.Uuid
  previousVersion   ProjectThreeMFFile? @relation("FileHistory", fields: [previousVersionId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  nextVersion       ProjectThreeMFFile? @relation("FileHistory")

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  printRuns      PrintRun[]
  productId      String?               @db.Uuid
  product        Product?              @relation(fields: [productId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  materials      Item[] // Relazione legacy (per compatibilità)
  fileMaterials  ProjectFileMaterial[] // Nuova relazione con peso specifico del file
  productionJobs ProductionJob[]       @relation("JobsToFiles")
  parts          ProjectPart[]         @relation("ProjectParts")
  feedbacks      FarmFeedback[]

  @@index([productId])
  @@index([status])
  @@index([previousVersionId])
  @@schema("print-farm")
}

/// Relazione tra file 3MF e materiali con peso specifico usato nel file.
/// I grammi sono specifici del file, non dell'anagrafica materiali.
model ProjectFileMaterial {
  id String @id @default(uuid()) @db.Uuid

  fileId String             @db.Uuid
  file   ProjectThreeMFFile @relation(fields: [fileId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  /// Indice del filamento *nel 3MF* (0-based).
  /// Corrisponde alla posizione del filamento nell'elenco estratto da `Metadata/slice_info.config`
  /// (es. `fileFilaments[*].fileFilamentIndex`) e serve per ricostruire correttamente il mapping AMS/tray.
  fileFilamentIndex Int @default(1)
  /// ID filamento in slice_info.config (spesso 1-based, string)
  fileFilamentId    String?
  /// tray_info_idx (es. GFB99)
  trayInfoIdx       String?
  /// Tipo filamento nel file (PLA/ABS/...)
  filamentType      String?

  /// Materiale inventario associato (opzionale, può essere mappato successivamente)
  materialId String? @db.Uuid
  material   Item?   @relation("FileMaterialUsage", fields: [materialId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  usedWeight Decimal @db.Decimal(12, 2) // Grammi usati nel file (per quel filamento)
  colorUsed  String? // Colore usato (tipicamente il colore del filamento nel file)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([fileId, fileFilamentIndex]) // Un filamento (indice) una sola volta per file
  @@index([fileId])
  @@index([materialId])
  @@schema("print-farm")
}

/// Rappresenta una parte nel file 3MF collegata a una ProductPart del prodotto.
/// Traccia la quantità di parti nel file e il peso calcolato per singola parte.
model ProjectPart {
  id               String   @id @default(uuid()) @db.Uuid
  quantity         Int      @default(0) // Quantità di parti nel file 3MF
  weight           Decimal? @db.Decimal(12, 2) // Peso calcolato per singola parte (totalWeight / quantity)
  imageFromFileUrl String? // URL immagine estratta dal file 3MF

  productPartId String?      @db.Uuid
  productPart   ProductPart? @relation(fields: [productPartId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  productId String?  @db.Uuid
  product   Product? @relation(fields: [productId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  fileId String             @db.Uuid
  file   ProjectThreeMFFile @relation("ProjectParts", fields: [fileId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  productionJobs ProductionJob[] @relation("ProductionJobParts")

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([productPartId])
  @@index([productId])
  @@index([fileId])
  @@schema("print-farm")
}

/// Job di stampa 3D per una specifica parte.
/// Collegato a un ProductOrder (ordine di produzione dall'inventario).
/// Ogni ProductionJob produce N pezzi di una singola parte usando un file 3MF.
model ProductionJob {
  id                 String               @id @default(uuid()) @db.Uuid
  /// Progressivo numerico leggibile (BIGINT Postgres) per uso umano/reportistica.
  /// Nota: lasciamo `id` UUID come PK per non rompere relazioni/migrazioni; questo è solo un numero sequenziale.
  number             BigInt               @unique @default(autoincrement()) @db.BigInt
  priority           Int                  @default(1) // 1=low, 2=medium, 3=high, 4=critical
  assignedPrinterIds String[]
  estimatedTime      Decimal?             @db.Decimal(12, 2) // Tempo stimato in minuti
  eta                DateTime?            @db.Timestamptz(6)
  startedAt          DateTime?            @db.Timestamptz(6)
  finishedAt         DateTime?            @db.Timestamptz(6)
  status             FarmProductionStatus @default(READY_TO_PRODUCE)
  quantity           Int // Quantità totale da produrre
  quantityPrinted    Int                  @default(0) // Pezzi stampati con successo
  quantityFailed     Int                  @default(0) // Pezzi falliti/scartati
  notes              String? // Note operative

  // Relazioni con file e parti
  files     ProjectThreeMFFile[] @relation("JobsToFiles")
  printRuns PrintRun[]
  parts     ProjectPart[]        @relation("ProductionJobParts")
  filaments Item[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  // Collegamento al Prodotto
  productId String?  @db.Uuid
  product   Product? @relation(fields: [productId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  // Collegamento alla Parte specifica del prodotto
  productPartId String?      @db.Uuid
  productPart   ProductPart? @relation(fields: [productPartId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  // Collegamento all'Ordine di Produzione (dall'inventario)
  productOrderId String?       @db.Uuid
  productOrder   ProductOrder? @relation("ProductOrderJobs", fields: [productOrderId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Collegamento logico all'AssemblyOrder che ha generato questo job (cron).
  /// È un campo di tracking: non è una relazione Prisma perché `AssemblyOrder` vive nello schema "inventory".
  assemblyOrderId String? @db.Uuid

  // Collegamento al Lotto di Produzione (per tracciabilità ISO)
  productionLotId String?        @db.Uuid
  productionLot   ProductionLot? @relation(fields: [productionLotId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  powerConsumed Decimal? @db.Decimal(12, 3) // Consumo energia in kWh

  // Odette assegnate per lo scarico pezzi (pre-assegnate all'avvio del job)
  odettes Odette[]

  /// Assegnazioni stampanti per questo job
  printerAssignments PrinterAssignment[]

  failureLogs PrintFailureLog[]

  @@index([productOrderId])
  @@index([assemblyOrderId])
  @@index([productId])
  @@index([productPartId])
  @@index([status])
  @@schema("print-farm")
}

model PrintRun {
  id         String    @id @default(uuid()) @db.Uuid
  /// Progressivo numerico leggibile (BIGINT Postgres) per uso umano/reportistica.
  /// Nota: lasciamo `id` UUID come PK per non rompere relazioni/migrazioni; questo è solo un numero sequenziale.
  number     BigInt    @unique @default(autoincrement()) @db.BigInt
  startedAt  DateTime? @db.Timestamptz(6)
  finishedAt DateTime? @db.Timestamptz(6)
  /// Quantità attesa/target per questa singola run.
  /// Utile per run con "skip oggetti" (es. completamento job) e per audit/metriche.
  expectedQuantity Int?

  /// Stampante associata a questa run.
  ///
  /// Per le run “pianificate” l'informazione passa da `assignment -> printer`.
  /// Questo campo serve soprattutto per run “unplanned/custom” (es. stampa avviata dal pannello della stampante),
  /// dove potremmo non avere una `PrinterAssignment` da collegare.
  printerId String?  @db.Uuid
  printer   Printer? @relation("PrintRunPrinter", fields: [printerId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Assegnazione stampante (PrinterAssignment) che ha generato/gestito questa run.
  /// Serve a legare l'esecuzione reale (run) al workflow operativo (assignment).
  assignmentId String?            @db.Uuid
  assignment   PrinterAssignment? @relation(fields: [assignmentId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  productionJob   ProductionJob? @relation(fields: [productionJobId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  productionJobId String?        @db.Uuid

  /// File stampato, se noto e presente nel sistema.
  ///
  /// Nota: per supportare run “unplanned/custom” rendiamo `fileId` opzionale: in quel caso useremo `taskFileName`
  /// (nome file riportato dalla stampante) finché non riusciamo a risolvere/mappare un `ProjectThreeMFFile`.
  filePrinted ProjectThreeMFFile? @relation(fields: [fileId], references: [id])
  fileId      String?             @db.Uuid

  /// Identificativo task runtime riportato dalla stampante (NON unico globalmente: può ripetersi tra stampanti e nel tempo).
  /// Va sempre interpretato insieme a `printerId`/`assignment` e ad un timestamp di osservazione (`detectedAt`).
  taskId Int? @db.SmallInt

  /// Nome file riportato dalla stampante (es. `.3mf` o `.gcode`) anche se non presente come `ProjectThreeMFFile`.
  taskFileName String?

  /// Timestamp lato server della prima osservazione (firstSeen) di questa run/task tramite WSS/MQTT.
  /// Non è lo "startedAt" della stampante: serve solo per disambiguare `taskId` riusati nel tempo.
  detectedAt DateTime? @db.Timestamptz(6)

  /// Origine della run (UI, stampante, ecc.) per audit e riconciliazione.
  source PrintRunSource @default(UI)

  printTimeMinutes   Decimal?       @db.Decimal(12, 2)
  powerConsumed      Decimal?       @db.Decimal(12, 3)
  energyCostSnapshot Decimal?       @db.Decimal(12, 2) // Costo energia al momento della stampa
  quantitySuccess    Int            @default(0)
  quantityFailed     Int            @default(0)
  status             PrintRunStatus @default(PENDING)
  filaments          Item[]
  spoolId            String?        @db.Uuid // Bobina usata per questa run
  spool              FilamentSpool? @relation(fields: [spoolId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  notes              String?

  failureLogs PrintFailureLog[]

  /// Metriche aggiuntive per questa run (consumo filamento, scarto)
  metrics PrintRunMetrics?

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([printerId])
  @@index([printerId, taskId])
  @@index([assignmentId])
  @@index([productionJobId])
  @@index([fileId])
  @@index([spoolId])
  @@index([status])
  @@index([startedAt])
  @@schema("print-farm")
}

/// Origine/contesto con cui è stata generata una PrintRun.
/// Utile per distinguere run “pianificate” dall'app vs run avviate direttamente dalla stampante o da processi automatici.
enum PrintRunSource {
  UI
  PRINTER
  SYSTEM

  @@schema("print-farm")
}

model Printer {
  id     String       @id @default(uuid()) @db.Uuid
  serial String? // Serial number BambuLab (es. 00M09C433002451)
  name   String
  brand  PrinterBrand @default(BAMBU_LAB)

  model   PrinterModel @relation(fields: [modelId], references: [id])
  modelId Int

  imageUrl       String?
  ipAddress      String?
  softwareType   SoftwareType @default(BAMBU_STUDIO)
  accessCode     String?
  apiKey         String?
  peakPower      Decimal?     @db.Decimal(12, 2)
  runPower       Decimal?     @db.Decimal(12, 2)
  nozzleDiameter Decimal      @default(0.4) @db.Decimal(4, 2)
  nozzleType     String       @default("Hardened Steel")
  structure      String       @default("CoreXY")
  ams            Boolean?
  pushAllTimeout Int?

  /// Stato runtime dalla stampante (WebSocket) - volatile
  status PrinterStatus @default(OFFLINE)

  /// Stato operativo (persistente) usato dalla UI e dalla logica applicativa.
  /// Consiglio: evitare di "scriverlo" in tanti punti diversi. Meglio calcolarlo con una funzione
  /// deterministica che combina: override manuale + issue attive + assignment/coda + stato WSS.
  operationalStatus PrinterOperationalStatus @default(AVAILABLE)

  /// True quando il piatto è *attivamente* in riscaldamento verso il target (indipendente da operationalStatus).
  /// Viene aggiornato dal backend in base a `bedTemp` e `bedTargetTemp` con isteresi (evita toggle rapido).
  isBedHeating Boolean @default(false)

  /// --- HEALTH / TELEMETRIA ---
  /// Ultimo aggiornamento ricevuto dalla stampante via WebSocket.
  lastWssAt  DateTime? @db.Timestamptz(6)
  /// Ultimo aggiornamento ricevuto via MQTT (errori/eventi).
  lastMqttAt DateTime? @db.Timestamptz(6)

  /// --- OVERRIDE MANUALE (OPERATORE) ---
  /// Override esplicito impostato dall'operatore (es. MAINTENANCE/DISABLED).
  /// Se presente, deve avere precedenza sullo stato derivato.
  manualOverrideStatus PrinterManualOverrideStatus?
  manualOverrideReason String?
  /// User ID (stringa) che ha impostato l'override (evita vincoli cross-schema).
  manualOverrideBy     String?
  manualOverrideAt     DateTime?                    @db.Timestamptz(6)

  /// --- STATO PIATTO / SCARICO ---
  /// True quando il piatto è considerato "occupato" e serve scarico (anche in caso di FAILED).
  bedOccupied             Boolean            @default(false)
  bedOccupiedAt           DateTime?          @db.Timestamptz(6)
  /// Assignment che attualmente "occupa" il piatto (se noto).
  bedOccupiedAssignmentId String?            @unique @db.Uuid
  bedOccupiedAssignment   PrinterAssignment? @relation("BedOccupiedAssignment", fields: [bedOccupiedAssignmentId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Posizione fisica della stampante nella print farm (fila/slot di magazzino).
  locationId String?            @db.Uuid
  location   WarehouseLocation? @relation(fields: [locationId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  // Gestione Preferenze e Assegnazione
  currentMaterialId String?        @db.Uuid // ID dell'Item (filamento) attualmente caricato
  currentSpoolId    String?        @db.Uuid // ID della bobina (Virtuale o Fisica) attualmente montata
  currentSpool      FilamentSpool? @relation("ActiveSpool", fields: [currentSpoolId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  preferredTags     String[] // es. ["PETG", "BLACK", "PLA_SILK"] - per suggerire l'assegnazione

  logs            PrinterLogs[]
  maintenanceLogs PrinterMaintenanceLog[]
  feedbacks       FarmFeedback[]
  /// Issue operative/tecniche aperte o risolte (derivate da MQTT/WSS o inserite manualmente).
  issues          PrinterIssue[]

  printerMacros PrinterMacro[]    @relation("PrinterCompatibility")
  failureLogs   PrintFailureLog[]
  spools        FilamentSpool[]   @relation("MountedSpool")

  /// Assegnazioni job a questa stampante (coda di lavoro)
  assignments PrinterAssignment[]

  /// PrintRun collegate direttamente a questa stampante (supporto run “unplanned/custom”).
  /// Relazione separata da `assignments -> printRuns` quindi deve essere nominata.
  printRuns PrintRun[] @relation("PrintRunPrinter")

  /// Storico raccolte pezzi da questa stampante
  harvests      PrinterHarvest[]
  /// Storico carichi filamento su questa stampante
  filamentLoads PrinterFilamentLoad[]

  /// Slot AMS per stampanti con AMS.
  /// Ogni slot può contenere una spool. Per stampanti senza AMS, usare currentSpoolId.
  amsSlots PrinterAmsSlot[] @relation("PrinterAmsSlots")

  /// Eventi di cambio stato per calcolo uptime/utilization
  stateEvents PrinterStateEvent[]
  /// Eventi di downtime per KPI
  downtimeEvents PrinterDowntimeEvent[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([operationalStatus])
  @@index([manualOverrideStatus])
  @@index([bedOccupied])
  @@index([locationId])
  @@schema("print-farm")
}

model PrinterModel {
  id          Int    @id @default(autoincrement())
  name        String @unique
  deviceModel String

  /// Dimensioni piano di stampa (mm)
  buildPlateWidth  Decimal? @db.Decimal(8, 2) // Larghezza piano (X) in mm
  buildPlateDepth  Decimal? @db.Decimal(8, 2) // Profondità piano (Y) in mm
  buildPlateHeight Decimal? @db.Decimal(8, 2) // Altezza massima (Z) in mm

  printers      Printer[]
  errorCodes    ErrorCode[]    @relation("PrinterModelErrorCode")
  /// Macro G-code compatibili con questo modello di stampante
  printerMacros PrinterMacro[] @relation("PrinterModelMacroCompatibility")

  @@schema("print-farm")
}

model PrinterMacro {
  id                   Int            @id @default(autoincrement())
  name                 String
  description          String
  gcode                Json
  printerCompatibility String[]
  printers             Printer[]      @relation("PrinterCompatibility")
  /// Modelli di stampante con cui la macro è compatibile
  printerModels        PrinterModel[] @relation("PrinterModelMacroCompatibility")
  createdAt            DateTime       @default(now()) @db.Timestamptz(6)
  updatedAt            DateTime       @default(now()) @updatedAt @db.Timestamptz(6)

  @@schema("print-farm")
}

enum ErrorSeverity {
  WARNING
  CRITICAL

  @@schema("print-farm")
}

/// Categoria funzionale dell'errore.
/// Determina come il backend/UI reagiscono all'errore (es. impostare operationalStatus).
enum ErrorCategory {
  WARNING         // Avviso non bloccante, la stampa può continuare
  RECOVERABLE     // Errore risolvibile senza intervento urgente
  BLOCKING        // Errore bloccante, richiede intervento immediato
  FILAMENT_RUNOUT // Filamento esaurito (runtime → FILAMENT_RUNOUT status)
  IGNORE          // Errore ignorato (non mostrare notifiche/badge)

  @@schema("print-farm")
}

model ErrorCode {
  id            Int            @id @default(autoincrement())
  code          String         @unique
  description   String?
  printerModels PrinterModel[] @relation("PrinterModelErrorCode")
  solutions     String[]
  skipthiserror Boolean        @default(false)
  severity      ErrorSeverity  @default(WARNING)
  errorType     ErrorType      @default(HMS)
  /// Categoria funzionale: determina il comportamento del backend (es. FILAMENT_RUNOUT → operationalStatus).
  category      ErrorCategory  @default(WARNING)
  action        String?
  guideUrl      String?
  qrCodeUrl     String?
  qrCodeData    String?
  logs          PrinterLogs[]
  issues        PrinterIssue[]
  createdAt     DateTime       @default(now()) @db.Timestamptz(6)
  updatedAt     DateTime       @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([category])
  @@schema("print-farm")
}

enum ErrorType {
  HMS
  PRINTING

  @@schema("print-farm")
}

model PrinterLogs {
  id          Int    @id @default(autoincrement())
  printerId   String @db.Uuid
  errorCodeId Int

  errorCode ErrorCode @relation(fields: [errorCodeId], references: [id])
  printer   Printer   @relation(fields: [printerId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  occurredAt DateTime  @default(now()) @db.Timestamptz(6)
  fixedAt    DateTime? @db.Timestamptz(6)
  createdAt  DateTime  @default(now()) @db.Timestamptz(6)

  @@index([printerId])
  @@index([occurredAt])
  @@schema("print-farm")
}

model FarmSettings {
  id           Int          @id @default(autoincrement())
  value        Json         @map("settings")
  settingsname String
  settingstype SettingsType

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([settingsname, settingstype])
  @@map("Settings")
  @@schema("print-farm")
}

enum SettingsType {
  PRINTER
  TOTAL_AVAILABLE_POWER
  COST_PER_KWH
  WORKHOURS
  WORKDAYS
  USER
  GENERAL

  @@schema("print-farm")
}

enum FarmProductionStatus {
  READY_TO_PRODUCE // Pronto per essere assegnato
  NEEDS_CONFIGURATION // Manca configurazione (file, materiali, ecc.)
  AWAITING_RESOURCES // Configurato ma mancano risorse (odette, stampanti libere)
  IN_PROGRESS // In produzione
  FULFILLED // Job completato, tutti i pezzi prodotti
  FAILED // Fallito

  @@schema("print-farm")
}

enum PrintRunStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED

  @@schema("print-farm")
}

enum PrinterStatus {
  FINISH
  RUNNING
  IDLE
  OFFLINE
  PAUSE
  PREPARE
  FAILED
  SLICING
  ERROR

  @@schema("print-farm")
}

/// Stato operativo della stampante (persistente, gestito da logica applicativa).
/// Questo stato è "superiore" rispetto al PrinterStatus che arriva dal WebSocket.
enum PrinterOperationalStatus {
  AVAILABLE // Pronta per nuovi job
  QUEUED // Ha job in coda, in attesa di partire (non ancora in stampa)
  PRINTING // In stampa attiva (distingue da QUEUED che indica solo "in coda")
  NEEDS_SETUP // Richiede setup (file/configurazione) - ex TO_LOAD
  TO_HARVEST // Stampa completata, richiede scarico pezzi
  FILAMENT_RUNOUT // Filamento finito durante stampa (richiede ricarica)
  FILAMENT_SWAP_NEEDED // Serve cambio colore/materiale per prossimo job
  ERROR // Errore bloccante (richiede intervento)

  @@schema("print-farm")
}

/// Override manuale impostato dall'operatore.
/// Tiene separate le decisioni umane dallo stato derivato (WSS/MQTT/queue).
enum PrinterManualOverrideStatus {
  MAINTENANCE
  DISABLED

  @@schema("print-farm")
}

/// Stato di un'assegnazione stampante per un ProductionJob.
/// Flusso: SCHEDULED → QUEUED → PRINTING → TO_HARVEST → COMPLETED
enum AssignmentStatus {
  SCHEDULED  // Pianificato, NON parte automaticamente
  QUEUED     // In coda attiva, lo scheduler lo avvia appena c'è budget kW
  PRINTING   // In stampa attiva (1 solo per stampante)
  TO_HARVEST // Stampa finita, da scaricare
  COMPLETED  // Scaricato, tutto fatto
  FAILED     // Fallito
  CANCELLED  // Annullato

  @@schema("print-farm")
}

/// Assegnazione di una stampante a un ProductionJob.
/// Traccia la coda, lo stato, i tempi e lo scarico dei pezzi.
model PrinterAssignment {
  id     String @id @default(uuid()) @db.Uuid
  /// Progressivo numerico leggibile (BIGINT Postgres) per uso umano/reportistica.
  /// Nota: lasciamo `id` UUID come PK per non rompere relazioni/migrazioni; questo è solo un numero sequenziale.
  number BigInt @unique @default(autoincrement()) @db.BigInt

  /// Job di produzione assegnato.
  ///
  /// Nota: lo rendiamo opzionale per supportare stampe "unplanned" (senza job/prodotto),
  /// che comunque devono creare una `PrinterAssignment` per poter gestire harvest e stati operativi.
  productionJobId String?        @db.Uuid
  productionJob   ProductionJob? @relation(fields: [productionJobId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  /// Stampante assegnata
  printerId String  @db.Uuid
  printer   Printer @relation(fields: [printerId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  /// Relazione 1:1 (opzionale) per tracciare quale assignment "occupa" il piatto.
  /// È una relazione separata da `printer` quindi deve essere nominata.
  bedOccupiedOn Printer? @relation("BedOccupiedAssignment")

  /// Posizione in coda (0 = attuale, 1+ = in attesa)
  queuePosition Int              @default(0)
  status        AssignmentStatus @default(SCHEDULED)

  // === Timing ===
  scheduledAt DateTime? @db.Timestamptz(6) // Quando è stato schedulato
  startedAt   DateTime? @db.Timestamptz(6) // Inizio stampa effettivo
  completedAt DateTime? @db.Timestamptz(6) // Fine stampa

  /// Operazioni di raccolta pezzi associate a questa assegnazione
  harvests PrinterHarvest[]

  /// Operazioni di carico filamento associate
  filamentLoads PrinterFilamentLoad[]

  /// Run effettive collegate a questa assignment (storico esecuzioni reali).
  printRuns PrintRun[]

  /// Issue operative/tecniche collegate a questa assignment (opzionale).
  issues PrinterIssue[]

  // === Conteggi parti ===
  partsExpected   Int // Parti totali attese per questa stampa (micro-assignment)
  partsProduced   Int @default(0) // Parti prodotte ok
  partsRejected   Int @default(0) // Parti scartate

  // === Materiale ===
  /// Categoria materiale richiesto dal file (es. "PETG", "PLA")
  materialRequired  String?
  /// Colore richiesto (es. "RED", "BLACK")
  colorRequired     String?
  /// Se il materiale è stato cambiato per questo assignment
  materialChanged   Boolean   @default(false)
  /// Timestamp conferma cambio materiale
  materialChangedAt DateTime? @db.Timestamptz(6)

  // === Note ===
  notes String?


  /// Payload JSON per avvio stampa (usato dallo scheduler backend).
  /// Contiene tutte le informazioni per far partire la stampa anche a UI chiusa.
  /// Schema (v1): { version: 1, printerSerial, fileId?, filenameToPrint, plateNumber, useAms, amsMapping, options }
  startPayload Json?

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  /// Nota: NON usiamo più unique su (productionJobId, printerId) perché adottiamo la strategia
  /// "1 run = 1 assignment" (micro-assignments). Quindi per lo stesso job e la stessa stampante
  /// possono esistere più assignment (in coda).
  @@index([productionJobId, printerId])
  @@index([productionJobId])
  @@index([printerId])
  @@index([status])
  @@index([queuePosition])
  @@schema("print-farm")
}

enum SoftwareType {
  BAMBU_STUDIO
  MAINSAIL

  @@schema("print-farm")
}

enum PrinterBrand {
  BAMBU_LAB
  KLIPPER
  PRUSA

  @@schema("print-farm")
}

enum FileStatus {
  DRAFT // Caricato, non ancora verificato
  TESTING // In fase di stampa di prova
  APPROVED // Validato per produzione massiva
  ARCHIVED // Versione vecchia, non usare
  REJECTED // Test falliti, da buttare

  @@schema("print-farm")
}

/// Operazione di raccolta pezzi stampati dalla stampante all'odette (harvesting).
/// Traccia chi ha effettuato la raccolta, quando, e la qualità dei pezzi.
model PrinterHarvest {
  id String @id @default(uuid()) @db.Uuid

  /// Assegnazione da cui provengono i pezzi
  assignmentId String            @db.Uuid
  assignment   PrinterAssignment @relation(fields: [assignmentId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  /// Stampante da cui è stata effettuata la raccolta
  printerId String  @db.Uuid
  printer   Printer @relation(fields: [printerId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  /// Odette di destinazione (opzionale).
  /// Serve per permettere lo scarico anche quando non c'è un contenitore disponibile.
  odetteId String? @db.Uuid
  odette   Odette? @relation(fields: [odetteId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Operatore che ha effettuato la raccolta
  harvestedByUserId Int
  harvestedByUser   User @relation("PrinterHarvests", fields: [harvestedByUserId], references: [id], onDelete: Restrict)

  /// Timestamp raccolta
  harvestedAt DateTime @default(now()) @db.Timestamptz(6)

  // === Conteggi pezzi ===
  /// Pezzi raccolti correttamente
  partsAccepted Int @default(0)
  /// Pezzi scartati (difetti, errori)
  partsRejected Int @default(0)
  /// Pezzi totali (accepted + rejected)
  partsTotal    Int @default(0)

  // === Qualità ===
  /// Motivo scarto (se ci sono pezzi rejected)
  rejectReason String?
  /// Note dell'operatore
  notes        String?
  /// Foto/immagine dei pezzi (opzionale)
  imageUrl     String?

  // === Lotto ===
  /// Lotto di produzione associato
  productionLotId String?        @db.Uuid
  productionLot   ProductionLot? @relation(fields: [productionLotId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([assignmentId])
  @@index([printerId])
  @@index([odetteId])
  @@index([harvestedByUserId])
  @@index([harvestedAt])
  @@index([productionLotId])
  @@schema("print-farm")
}

/// Operazione di carico filamento/materiale sulla stampante.
/// Traccia il cambio bobina e la conferma di caricamento.
model PrinterFilamentLoad {
  id String @id @default(uuid()) @db.Uuid

  /// Assegnazione per cui viene effettuato il carico (opzionale)
  assignmentId String?            @db.Uuid
  assignment   PrinterAssignment? @relation(fields: [assignmentId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Stampante su cui viene caricato
  printerId String  @db.Uuid
  printer   Printer @relation(fields: [printerId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  /// Operatore che ha effettuato il carico
  loadedByUserId Int
  loadedByUser   User @relation("PrinterFilamentLoads", fields: [loadedByUserId], references: [id], onDelete: Restrict)

  /// Timestamp carico
  loadedAt DateTime @default(now()) @db.Timestamptz(6)

  // === Dettagli materiale ===
  /// Bobina caricata
  spoolId          String?        @db.Uuid
  spool            FilamentSpool? @relation(fields: [spoolId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  /// Materiale precedente (per tracking cambio)
  previousMaterial String?
  /// Materiale nuovo
  newMaterial      String?
  /// Colore nuovo
  newColor         String?

  /// Conferma che il carico è stato completato correttamente
  confirmed   Boolean   @default(false)
  confirmedAt DateTime? @db.Timestamptz(6)

  /// Note dell'operatore
  notes String?

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([assignmentId])
  @@index([printerId])
  @@index([loadedByUserId])
  @@index([loadedAt])
  @@schema("print-farm")
}
