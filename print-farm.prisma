/// File di progetto 3MF per la stampa 3D.
/// Include informazioni sul file, parametri di stampa, materiali usati e versionamento.
model ProjectThreeMFFile {
  id                       String   @id @default(uuid()) @db.Uuid
  filename                 String
  filepath                 String
  filesize                 Decimal  @db.Decimal(12, 3)
  projectName              String
  skus                     Sku[]    @relation("ProjectRelatedSku")
  imageUrl                 String   @default("")
  estimatedDurationMinutes Int // tempo stimato in minuti
  compatiblePrinters       String[] // nomi stampanti compatibili
  zHeight                  Decimal  @db.Decimal(12, 2) // altezza modello in mm
  nozzleDiameter           Decimal  @db.Decimal(4, 2) // diametro ugello in mm
  partCount                Int // numero di parti nel plate
  totalLayers              Int // numero di strati
  totalFilamentWeight      Decimal? @db.Decimal(12, 2) // peso totale filamento usato in grammi
  plateNumber              Int      @default(1) // Numero del plate (index) per il comando di stampa

  /// Metadati estratti da `Metadata/slice_info.config` (Bambu Studio)
  printerModelId String? // es. "C12"
  supportsUsed   Boolean @default(false)
  objectCount    Int     @default(0) // numero <object skipped="false" />
  /// Oggetti nel plate (per skip/selezione oggetti singoli in stampa)
  /// JSON array: [{ identifyId: number, name: string, skipped: boolean }]
  sliceObjects   Json?

  /// Percentuale di riempimento del piano (es. 0.70 = 70%)
  /// Usata per stimare l'area delle parti quando non conosciamo le dimensioni esatte
  plateFillPercentage Decimal @default(0.70) @db.Decimal(3, 2)

  // Versionamento
  version   Int        @default(1)
  status    FileStatus @default(DRAFT)
  changeLog String? // Es. "Aumentato riempimento al 20%"

  // Self-relation per tracciare la storia delle versioni (v2 -> v1)
  previousVersionId String?             @unique @db.Uuid
  previousVersion   ProjectThreeMFFile? @relation("FileHistory", fields: [previousVersionId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  nextVersion       ProjectThreeMFFile? @relation("FileHistory")

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  printRuns      PrintRun[]
  productId      String?               @db.Uuid
  product        Product?              @relation(fields: [productId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  /// Parte principale associata al file (opzionale).
  /// Nota: il dettaglio multi-parte rimane in `ProjectPart`, ma questo campo serve per risoluzioni rapide e affidabili.
  productPartId  String?               @db.Uuid
  productPart    ProductPart?          @relation("ProductPartFiles", fields: [productPartId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  materials      Item[] // Relazione legacy (per compatibilità)
  fileMaterials  ProjectFileMaterial[] // Nuova relazione con peso specifico del file
  productionJobs ProductionJob[]       @relation("JobsToFiles")
  parts          ProjectPart[]         @relation("ProjectParts")
  feedbacks      FarmFeedback[]

  /// Task di accodamento persistenti (flusso "send to print")
  queueTasks QueueTask[] @relation("FileQueueTasks")

  @@index([productId])
  @@index([productPartId])
  @@index([status])
  @@index([previousVersionId])
  @@schema("print-farm")
}

/// Relazione tra file 3MF e materiali con peso specifico usato nel file.
/// I grammi sono specifici del file, non dell'anagrafica materiali.
model ProjectFileMaterial {
  id String @id @default(uuid()) @db.Uuid

  fileId String             @db.Uuid
  file   ProjectThreeMFFile @relation(fields: [fileId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  /// Indice del filamento *nel 3MF* (0-based).
  /// Corrisponde alla posizione del filamento nell'elenco estratto da `Metadata/slice_info.config`
  /// (es. `fileFilaments[*].fileFilamentIndex`) e serve per ricostruire correttamente il mapping AMS/tray.
  fileFilamentIndex Int     @default(1)
  /// ID filamento in slice_info.config (spesso 1-based, string)
  fileFilamentId    String?
  /// tray_info_idx (es. GFB99)
  trayInfoIdx       String?
  /// Tipo filamento nel file (PLA/ABS/...)
  filamentType      String?

  /// Materiale inventario associato (opzionale, può essere mappato successivamente)
  materialId String? @db.Uuid
  material   Item?   @relation("FileMaterialUsage", fields: [materialId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  usedWeight Decimal @db.Decimal(12, 2) // Grammi usati nel file (per quel filamento)
  colorUsed  String? // Colore usato (tipicamente il colore del filamento nel file)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([fileId, fileFilamentIndex]) // Un filamento (indice) una sola volta per file
  @@index([fileId])
  @@index([materialId])
  @@schema("print-farm")
}

/// Rappresenta una parte nel file 3MF collegata a una ProductPart del prodotto.
/// Traccia la quantità di parti nel file e il peso calcolato per singola parte.
model ProjectPart {
  id               String   @id @default(uuid()) @db.Uuid
  quantity         Int      @default(0) // Quantità di parti nel file 3MF
  weight           Decimal? @db.Decimal(12, 2) // Peso calcolato per singola parte (totalWeight / quantity)
  imageFromFileUrl String? // URL immagine estratta dal file 3MF

  productPartId String?      @db.Uuid
  productPart   ProductPart? @relation(fields: [productPartId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  productId String?  @db.Uuid
  product   Product? @relation(fields: [productId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  fileId String             @db.Uuid
  file   ProjectThreeMFFile @relation("ProjectParts", fields: [fileId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  productionJobs ProductionJob[] @relation("ProductionJobParts")

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([productPartId])
  @@index([productId])
  @@index([fileId])
  @@schema("print-farm")
}

/// Job di stampa 3D per una specifica parte.
/// Collegato a un ProductOrder (ordine di produzione dall'inventario).
/// Ogni ProductionJob produce N pezzi di una singola parte usando un file 3MF.
model ProductionJob {
  id                 String               @id @default(uuid()) @db.Uuid
  /// Progressivo numerico leggibile (BIGINT Postgres) per uso umano/reportistica.
  /// Nota: lasciamo `id` UUID come PK per non rompere relazioni/migrazioni; questo è solo un numero sequenziale.
  number             BigInt               @unique @default(autoincrement()) @db.BigInt
  priority           Int                  @default(1) // 1=low, 2=medium, 3=high, 4=critical
  assignedPrinterIds String[]
  estimatedTime      Decimal?             @db.Decimal(12, 2) // Tempo stimato in minuti
  eta                DateTime?            @db.Timestamptz(6)
  startedAt          DateTime?            @db.Timestamptz(6)
  finishedAt         DateTime?            @db.Timestamptz(6)
  status             FarmProductionStatus @default(READY_TO_PRODUCE)
  quantity           Int // Quantità totale da produrre
  quantityPrinted    Int                  @default(0) // Pezzi stampati con successo
  quantityFailed     Int                  @default(0) // Pezzi falliti/scartati
  notes              String? // Note operative

  // Relazioni con file e parti
  files     ProjectThreeMFFile[] @relation("JobsToFiles")
  printRuns PrintRun[]
  parts     ProjectPart[]        @relation("ProductionJobParts")
  filaments Item[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  // Collegamento al Prodotto
  productId String?  @db.Uuid
  product   Product? @relation(fields: [productId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  // Collegamento alla Parte specifica del prodotto
  productPartId String?      @db.Uuid
  productPart   ProductPart? @relation(fields: [productPartId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  // Collegamento all'Ordine di Produzione (dall'inventario)
  productOrderId String?       @db.Uuid
  productOrder   ProductOrder? @relation("ProductOrderJobs", fields: [productOrderId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Collegamento logico all'AssemblyOrder che ha generato questo job (cron).
  /// È un campo di tracking: non è una relazione Prisma perché `AssemblyOrder` vive nello schema "inventory".
  assemblyOrderId String? @db.Uuid

  // Collegamento al Lotto di Produzione (per tracciabilità ISO)
  productionLotId String?        @db.Uuid
  productionLot   ProductionLot? @relation(fields: [productionLotId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  powerConsumed Decimal? @db.Decimal(12, 3) // Consumo energia in kWh

  // Odette assegnate per lo scarico pezzi (pre-assegnate all'avvio del job)
  odettes Odette[]

  /// Assegnazioni stampanti per questo job
  printerAssignments PrinterAssignment[]

  /// Task di accodamento persistenti (flusso "send to print")
  queueTasks QueueTask[] @relation("JobQueueTasks")

  failureLogs PrintFailureLog[]

  @@index([productOrderId])
  @@index([assemblyOrderId])
  @@index([productId])
  @@index([productPartId])
  @@index([status])
  @@schema("print-farm")
}

model PrintRun {
  id               String    @id @default(uuid()) @db.Uuid
  /// Progressivo numerico leggibile (BIGINT Postgres) per uso umano/reportistica.
  /// Nota: lasciamo `id` UUID come PK per non rompere relazioni/migrazioni; questo è solo un numero sequenziale.
  number           BigInt    @unique @default(autoincrement()) @db.BigInt
  startedAt        DateTime? @db.Timestamptz(6)
  finishedAt       DateTime? @db.Timestamptz(6)
  /// Quantità attesa/target per questa singola run.
  /// Utile per run con "skip oggetti" (es. completamento job) e per audit/metriche.
  expectedQuantity Int?

  /// Stampante associata a questa run.
  ///
  /// Per le run “pianificate” l'informazione passa da `assignment -> printer`.
  /// Questo campo serve soprattutto per run “unplanned/custom” (es. stampa avviata dal pannello della stampante),
  /// dove potremmo non avere una `PrinterAssignment` da collegare.
  printerId String?  @db.Uuid
  printer   Printer? @relation("PrintRunPrinter", fields: [printerId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Assegnazione stampante (PrinterAssignment) che ha generato/gestito questa run.
  /// Serve a legare l'esecuzione reale (run) al workflow operativo (assignment).
  assignmentId String?            @db.Uuid
  assignment   PrinterAssignment? @relation(fields: [assignmentId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  productionJob   ProductionJob? @relation(fields: [productionJobId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  productionJobId String?        @db.Uuid

  /// File stampato, se noto e presente nel sistema.
  ///
  /// Nota: per supportare run “unplanned/custom” rendiamo `fileId` opzionale: in quel caso useremo `taskFileName`
  /// (nome file riportato dalla stampante) finché non riusciamo a risolvere/mappare un `ProjectThreeMFFile`.
  filePrinted ProjectThreeMFFile? @relation(fields: [fileId], references: [id])
  fileId      String?             @db.Uuid

  /// Identificativo task runtime riportato dalla stampante (NON unico globalmente: può ripetersi tra stampanti e nel tempo).
  /// Va sempre interpretato insieme a `printerId`/`assignment` e ad un timestamp di osservazione (`detectedAt`).
  taskId Int? @db.SmallInt

  /// Nome file riportato dalla stampante (es. `.3mf` o `.gcode`) anche se non presente come `ProjectThreeMFFile`.
  taskFileName String?

  /// Timestamp lato server della prima osservazione (firstSeen) di questa run/task tramite WSS/MQTT.
  /// Non è lo "startedAt" della stampante: serve solo per disambiguare `taskId` riusati nel tempo.
  detectedAt DateTime? @db.Timestamptz(6)

  /// Origine della run (UI, stampante, ecc.) per audit e riconciliazione.
  source PrintRunSource @default(UI)

  printTimeMinutes   Decimal?       @db.Decimal(12, 2)
  powerConsumed      Decimal?       @db.Decimal(12, 3)
  energyCostSnapshot Decimal?       @db.Decimal(12, 2) // Costo energia al momento della stampa
  quantitySuccess    Int            @default(0)
  quantityFailed     Int            @default(0)
  status             PrintRunStatus @default(PENDING)
  /// Percentuale di completamento al termine della run (0-100). Salvato alla finalizzazione (COMPLETED/FAILED).
  completionPercent  Int?           @db.SmallInt
  filaments          Item[]
  spoolId            String?        @db.Uuid // Bobina usata per questa run
  spool              FilamentSpool? @relation(fields: [spoolId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  notes              String?

  failureLogs PrintFailureLog[]

  /// Metriche aggiuntive per questa run (consumo filamento, scarto)
  metrics PrintRunMetrics?

  /// Telemetria (opzionale) correlata a questa run:
  /// - eventi di cambio stato (quando si riesce a determinare printRunId)
  /// - eventi di downtime correlati
  stateEvents    PrinterStateEvent[]    @relation("PrintRunStateEvents")
  downtimeEvents PrinterDowntimeEvent[] @relation("PrintRunDowntimeEvents")

  /// Operazioni di raccolta pezzi associate a questa run.
  /// Utile specialmente per run unplanned/manuali dove l'assignment potrebbe non essere significativa.
  harvests PrinterHarvest[]

  /// Task di accodamento che ha generato questa run (se presente)
  queueTask QueueTask? @relation("QueueTaskPrintRun")

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([printerId])
  @@index([printerId, taskId])
  @@index([assignmentId])
  @@index([productionJobId])
  @@index([fileId])
  @@index([spoolId])
  @@index([status])
  @@index([startedAt])
  @@schema("print-farm")
}

/// Origine/contesto con cui è stata generata una PrintRun.
/// Utile per distinguere run “pianificate” dall'app vs run avviate direttamente dalla stampante o da processi automatici.
enum PrintRunSource {
  UI
  PRINTER
  SYSTEM

  @@schema("print-farm")
}

model Printer {
  id     String       @id @default(uuid()) @db.Uuid
  serial String? // Serial number BambuLab (es. 00M09C433002451)
  name   String
  brand  PrinterBrand @default(BAMBU_LAB)

  model   PrinterModel @relation(fields: [modelId], references: [id])
  modelId Int

  imageUrl       String?
  ipAddress      String?
  softwareType   SoftwareType @default(BAMBU_STUDIO)
  accessCode     String?
  apiKey         String?
  peakPower      Decimal?     @db.Decimal(12, 2)
  runPower       Decimal?     @db.Decimal(12, 2)
  nozzleDiameter Decimal      @default(0.4) @db.Decimal(4, 2)
  nozzleType     String       @default("Hardened Steel")
  structure      String       @default("CoreXY")
  ams            Boolean?
  /// Modello AMS collegato (se presente). Serve per stimare consumi AMS (standby/working/drying).
  amsModel       AmsModel?
  pushAllTimeout Int?

  /// Stato runtime dalla stampante (WebSocket) - volatile
  status PrinterStatus @default(OFFLINE)

  /// Stato operativo (persistente) usato dalla UI e dalla logica applicativa.
  /// Consiglio: evitare di "scriverlo" in tanti punti diversi. Meglio calcolarlo con una funzione
  /// deterministica che combina: override manuale + issue attive + assignment/coda + stato WSS.
  operationalStatus PrinterOperationalStatus @default(AVAILABLE)

  /// True quando serve cambio filamento (colore/materiale) per poter far partire il prossimo job.
  /// È un flag persistente “overlay” separato da `operationalStatus` per evitare conflitti.
  needsFilamentSwap Boolean @default(false)

  /// True quando il piatto è *attivamente* in riscaldamento verso il target (indipendente da operationalStatus).
  /// Viene aggiornato dal backend in base a `bedTemp` e `bedTargetTemp` con isteresi (evita toggle rapido).
  isBedHeating Boolean @default(false)

  /// --- HEALTH / TELEMETRIA ---
  /// Ultimo aggiornamento ricevuto dalla stampante via WebSocket.
  lastWssAt  DateTime? @db.Timestamptz(6)
  /// Ultimo aggiornamento ricevuto via MQTT (errori/eventi).
  lastMqttAt DateTime? @db.Timestamptz(6)

  /// --- OVERRIDE MANUALE (OPERATORE) ---
  /// Override esplicito impostato dall'operatore (es. MAINTENANCE/DISABLED).
  /// Se presente, deve avere precedenza sullo stato derivato.
  manualOverrideStatus PrinterManualOverrideStatus?
  manualOverrideReason String?
  /// User ID (stringa) che ha impostato l'override (evita vincoli cross-schema).
  manualOverrideBy     String?
  manualOverrideAt     DateTime?                    @db.Timestamptz(6)

  /// --- STATO PIATTO / SCARICO ---
  /// True quando il piatto ha una stampa completata/terminata e richiede scarico pezzi.
  /// È un flag persistente “overlay” separato da `operationalStatus` per evitare conflitti.
  hasCompletedPrintOnBed             Boolean            @default(false)
  hasCompletedPrintOnBedAt           DateTime?          @db.Timestamptz(6)
  /// Assignment che attualmente "occupa" il piatto (se noto).
  hasCompletedPrintOnBedAssignmentId String?            @unique @db.Uuid
  hasCompletedPrintOnBedAssignment   PrinterAssignment? @relation("BedOccupiedAssignment", fields: [hasCompletedPrintOnBedAssignmentId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Posizione fisica della stampante nella print farm (fila/slot di magazzino).
  locationId String?            @db.Uuid
  location   WarehouseLocation? @relation(fields: [locationId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  // Gestione Preferenze e Assegnazione
  currentMaterialId String?        @db.Uuid // ID dell'Item (filamento) attualmente caricato
  currentSpoolId    String?        @db.Uuid // ID della bobina (Virtuale o Fisica) attualmente montata
  currentSpool      FilamentSpool? @relation("ActiveSpool", fields: [currentSpoolId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Snapshot "reported" dalla stampante per la spool esterna (NON tracciamento spool).
  /// Serve a salvare materiale/colore visto dalla stampante anche se:
  /// - non abbiamo ancora creato/assegnato una FilamentSpool tracciata
  /// - il frontend decide di assegnare una spool/materiale diverso (questi campi restano separati)
  externalReportedMaterialType String? // es. "PLA", "ABS", "PETG"
  externalReportedColor        String? // es. "BLACK", "RED", "#FF0000" (best-effort)
  externalReportedTrayInfoIdx  String? // se disponibile (Bambu tray_info_idx)
  externalReportedLastSeenAt   DateTime? @db.Timestamptz(6)

  /// Incongruenza fra filamento "reported" dalla stampante e spool tracciata nel DB.
  /// Settato dal backend WSS quando rileva che il materiale/colore riportato dal firmware
  /// non corrisponde alla spool associata (currentSpool o AMS slot).
  hasFilamentMismatch        Boolean   @default(false)
  filamentMismatchDetectedAt DateTime? @db.Timestamptz(6)
  filamentMismatchDetails    Json?     @db.JsonB

  /// Categorie materiali preferite per questa stampante (relazione M2M con Category filtrate per ItemType.MATERIAL).
  /// Serve per suggerire automaticamente l'assegnazione dei job in base al materiale richiesto.
  preferredMaterialCategories PrinterPreferredMaterialCategory[]

  logs            PrinterLogs[]
  maintenanceLogs PrinterMaintenanceLog[]
  feedbacks       FarmFeedback[]
  /// Issue operative/tecniche aperte o risolte (derivate da MQTT/WSS o inserite manualmente).
  issues          PrinterIssue[]

  printerMacros PrinterMacro[]    @relation("PrinterCompatibility")
  failureLogs   PrintFailureLog[]
  spools        FilamentSpool[]   @relation("MountedSpool")

  /// Assegnazioni job a questa stampante (coda di lavoro)
  assignments PrinterAssignment[]

  /// PrintRun collegate direttamente a questa stampante (supporto run "unplanned/custom").
  /// Relazione separata da `assignments -> printRuns` quindi deve essere nominata.
  printRuns PrintRun[] @relation("PrintRunPrinter")

  /// Storico raccolte pezzi da questa stampante
  harvests      PrinterHarvest[]
  /// Storico carichi filamento su questa stampante
  filamentLoads PrinterFilamentLoad[]

  /// Slot AMS per stampanti con AMS.
  /// Ogni slot può contenere una spool. Per stampanti senza AMS, usare currentSpoolId.
  amsSlots PrinterAmsSlot[] @relation("PrinterAmsSlots")

  /// Consumi energia aggregati giornalieri (per dashboard, include standby).
  energyDailySlices PrinterEnergyDailySlice[]

  /// Eventi di cambio stato per calcolo uptime/utilization
  stateEvents    PrinterStateEvent[]
  /// Eventi di downtime per KPI
  downtimeEvents PrinterDowntimeEvent[]

  /// Task di accodamento persistenti (flusso "send to print")
  queueTasks QueueTask[] @relation("PrinterQueueTasks")

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([operationalStatus])
  @@index([manualOverrideStatus])
  @@index([hasCompletedPrintOnBed])
  @@index([locationId])
  @@schema("print-farm")
}

model PrinterModel {
  id          Int    @id @default(autoincrement())
  name        String @unique
  deviceModel String

  /// Dimensioni piano di stampa (mm)
  buildPlateWidth  Decimal? @db.Decimal(8, 2) // Larghezza piano (X) in mm
  buildPlateDepth  Decimal? @db.Decimal(8, 2) // Profondità piano (Y) in mm
  buildPlateHeight Decimal? @db.Decimal(8, 2) // Altezza massima (Z) in mm

  printers       Printer[]
  /// Profili consumo energia per questo modello (per tensione/fase/materiale).
  energyProfiles PrinterModelEnergyProfile[]
  errorCodes     ErrorCode[]                 @relation("PrinterModelErrorCode")
  /// Macro G-code compatibili con questo modello di stampante
  printerMacros  PrinterMacro[]              @relation("PrinterModelMacroCompatibility")

  @@schema("print-farm")
}

// ============================================================================
// ENERGIA (profili + aggregazione giornaliera)
// ============================================================================

/// Tensione di alimentazione (usa V110/V220 per evitare problemi con enum che iniziano con numeri).
enum SupplyVoltage {
  V110
  V220

  @@schema("print-farm")
}

/// Fasi logiche usate per stimare consumo energia.
enum EnergyPhaseKey {
  /// Standby senza connessione/rete (best-effort).
  STANDBY_OFFLINE
  /// Standby con connessione WiFi/rete (best-effort).
  STANDBY_ONLINE
  /// Fase di riscaldamento (piatto in heating).
  PRINT_HEAT
  /// Fase di stampa a regime.
  PRINT_RUN

  @@schema("print-farm")
}

/// Modello di AMS collegato alla stampante (Bambu).
enum AmsModel {
  AMS
  AMS_LITE
  AMS_2_PRO
  AMS_HT

  @@schema("print-farm")
}

/// Fasi consumo AMS.
enum AmsPhaseKey {
  STANDBY
  WORKING
  DRYING

  @@schema("print-farm")
}

/// Profilo consumo energia per un modello stampante, con optional override per categoria materiale.
/// - `powerW` è in Watt (W) per evitare ambiguità kW/W.
model PrinterModelEnergyProfile {
  id String @id @default(uuid()) @db.Uuid

  printerModelId Int
  printerModel   PrinterModel @relation(fields: [printerModelId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  voltage SupplyVoltage
  phase   EnergyPhaseKey

  /// Override specifico per categoria materiale (solo per ItemType.MATERIAL). Se null, vale come default del modello/fase.
  materialCategoryId String?   @db.Uuid
  materialCategory   Category? @relation(fields: [materialCategoryId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  powerW Decimal @db.Decimal(12, 3)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([printerModelId, voltage, phase, materialCategoryId])
  @@index([printerModelId])
  @@index([materialCategoryId])
  @@index([voltage, phase])
  @@schema("print-farm")
}

/// Profilo consumo energia per AMS.
/// - `powerW` è in Watt (W).
model AmsEnergyProfile {
  id Int @id @default(autoincrement())

  amsModel AmsModel
  phase    AmsPhaseKey
  powerW   Decimal     @db.Decimal(12, 3)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([amsModel, phase])
  @@index([amsModel])
  @@schema("print-farm")
}

/// Slice giornaliera di energia (kWh) per stampante/fase.
/// Usata per grafici energia \"totale farm\" (include standby + stampa).
model PrinterEnergyDailySlice {
  id String @id @default(uuid()) @db.Uuid

  day DateTime @db.Date

  printerId String  @db.Uuid
  printer   Printer @relation(fields: [printerId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  phase EnergyPhaseKey

  /// Categoria materiale associata (opzionale; tipicamente valorizzata per PRINT_RUN).
  materialCategoryId String?   @db.Uuid
  materialCategory   Category? @relation(fields: [materialCategoryId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  kwh Decimal @db.Decimal(12, 6)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([day, printerId, phase, materialCategoryId])
  @@index([day])
  @@index([printerId])
  @@index([phase])
  @@index([materialCategoryId])
  @@schema("print-farm")
}

model PrinterMacro {
  id                   Int                  @id @default(autoincrement())
  name                 String
  description          String
  /// Categoria della macro (per filtri UI e organizzazione)
  category             PrinterMacroCategory @default(GENERIC)
  gcode                Json
  printerCompatibility String[]
  printers             Printer[]            @relation("PrinterCompatibility")
  /// Modelli di stampante con cui la macro è compatibile
  printerModels        PrinterModel[]       @relation("PrinterModelMacroCompatibility")
  createdAt            DateTime             @default(now()) @db.Timestamptz(6)
  updatedAt            DateTime             @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([category])
  @@schema("print-farm")
}

/// Categorie supportate per le macro G-code (organizzazione UI e flussi operativi).
enum PrinterMacroCategory {
  GENERIC
  UNLOAD_FILAMENT
  LOAD_FILAMENT
  BRIGHT_COLOR_START
  CLEANING
  CALIBRATION
  MAINTENANCE
  TEST_GENERAL

  @@schema("print-farm")
}

model ErrorCode {
  id            Int            @id @default(autoincrement())
  code          String         @unique
  description   String?
  printerModels PrinterModel[] @relation("PrinterModelErrorCode")
  solutions     String[]
  skipthiserror Boolean        @default(false)
  severity      ErrorSeverity  @default(WARNING)
  errorType     ErrorType      @default(HMS)
  /// Categoria funzionale: determina il comportamento del backend (es. FILAMENT_RUNOUT → operationalStatus).
  category      ErrorCategory  @default(WARNING)
  action        String?
  guideUrl      String?
  qrCodeUrl     String?
  qrCodeData    String?
  logs          PrinterLogs[]
  issues        PrinterIssue[]
  createdAt     DateTime       @default(now()) @db.Timestamptz(6)
  updatedAt     DateTime       @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([category])
  @@schema("print-farm")
}

enum ErrorSeverity {
  WARNING
  CRITICAL

  @@schema("print-farm")
}

/// Categoria funzionale dell'errore.
/// Determina come il backend/UI reagiscono all'errore (es. impostare operationalStatus).
enum ErrorCategory {
  WARNING // Avviso non bloccante, la stampa può continuare
  RECOVERABLE // Errore risolvibile senza intervento urgente
  BLOCKING // Errore bloccante, richiede intervento immediato
  FILAMENT_RUNOUT // Filamento esaurito (runtime → FILAMENT_RUNOUT status)
  IGNORE // Errore ignorato (non mostrare notifiche/badge)

  @@schema("print-farm")
}

enum ErrorType {
  HMS
  PRINTING

  @@schema("print-farm")
}

model PrinterLogs {
  id          Int    @id @default(autoincrement())
  printerId   String @db.Uuid
  errorCodeId Int

  errorCode ErrorCode @relation(fields: [errorCodeId], references: [id])
  printer   Printer   @relation(fields: [printerId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  occurredAt DateTime  @default(now()) @db.Timestamptz(6)
  fixedAt    DateTime? @db.Timestamptz(6)
  createdAt  DateTime  @default(now()) @db.Timestamptz(6)

  @@index([printerId])
  @@index([occurredAt])
  @@schema("print-farm")
}

model FarmSettings {
  id           Int          @id @default(autoincrement())
  value        Json         @map("settings")
  settingsname String
  settingstype SettingsType

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([settingsname, settingstype])
  @@map("Settings")
  @@schema("print-farm")
}

enum SettingsType {
  PRINTER
  TOTAL_AVAILABLE_POWER
  COST_PER_KWH
  WORKHOURS
  WORKDAYS
  USER
  GENERAL
  SCHEDULER_PAUSED

  @@schema("print-farm")
}

enum FarmProductionStatus {
  READY_TO_PRODUCE // Pronto per essere assegnato
  NEEDS_CONFIGURATION // Manca configurazione (file, materiali, ecc.)
  AWAITING_RESOURCES // Configurato ma mancano risorse (odette, stampanti libere)
  IN_PROGRESS // In produzione
  FULFILLED // Job completato, tutti i pezzi prodotti
  FAILED // Fallito

  @@schema("print-farm")
}

enum PrintRunStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED

  @@schema("print-farm")
}

enum PrinterStatus {
  FINISH
  RUNNING
  IDLE
  OFFLINE
  PAUSE
  PREPARE
  FAILED
  SLICING
  ERROR

  @@schema("print-farm")
}

/// Stato operativo della stampante (persistente, gestito da logica applicativa).
/// Questo stato è "superiore" rispetto al PrinterStatus che arriva dal WebSocket.
enum PrinterOperationalStatus {
  AVAILABLE // Pronta per nuovi job
  QUEUED // Ha job in coda, in attesa di partire (non ancora in stampa)
  PRINTING // In stampa attiva (distingue da QUEUED che indica solo "in coda")
  NEEDS_SETUP // Richiede setup (file/configurazione) - ex TO_LOAD
  FILAMENT_RUNOUT // Filamento finito durante stampa (richiede ricarica)
  ERROR // Errore bloccante (richiede intervento)

  @@schema("print-farm")
}

/// Override manuale impostato dall'operatore.
/// Tiene separate le decisioni umane dallo stato derivato (WSS/MQTT/queue).
enum PrinterManualOverrideStatus {
  MAINTENANCE
  DISABLED
  MANUAL_PRINTING

  @@schema("print-farm")
}

/// Stato di un'assegnazione stampante per un ProductionJob.
/// Flusso: SCHEDULED → QUEUED → PRINTING → TO_HARVEST → COMPLETED
/// Flusso errore: QUEUED → START_FAILED (self-heal: → QUEUED quando stampante esce da ERROR)
enum AssignmentStatus {
  SCHEDULED // Pianificato, NON parte automaticamente
  QUEUED // In coda attiva, lo scheduler lo avvia appena c'è budget kW
  PRINTING // In stampa attiva (1 solo per stampante)
  TO_HARVEST // Stampa finita, da scaricare
  COMPLETED // Scaricato, tutto fatto
  FAILED // Fallito
  CANCELLED // Annullato
  ERROR // Errore
  START_FAILED // Avvio fallito: stampante in errore, serve intervento. Self-heal quando la stampante si riprende.

  @@schema("print-farm")
}

/// Assegnazione di una stampante a un ProductionJob.
/// Traccia la coda, lo stato, i tempi e lo scarico dei pezzi.
model PrinterAssignment {
  id     String @id @default(uuid()) @db.Uuid
  /// Progressivo numerico leggibile (BIGINT Postgres) per uso umano/reportistica.
  /// Nota: lasciamo `id` UUID come PK per non rompere relazioni/migrazioni; questo è solo un numero sequenziale.
  number BigInt @unique @default(autoincrement()) @db.BigInt

  /// Job di produzione assegnato.
  ///
  /// Nota: lo rendiamo opzionale per supportare stampe "unplanned" (senza job/prodotto),
  /// che comunque devono creare una `PrinterAssignment` per poter gestire harvest e stati operativi.
  productionJobId String?        @db.Uuid
  productionJob   ProductionJob? @relation(fields: [productionJobId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  /// Parte (ProductPart) collegata a questa assignment.
  ///
  /// Serve a selezionare sempre il file corretto (APPROVED > DRAFT) per la parte,
  /// anche per stampe "unplanned" o quando startPayload.fileId è inattendibile.
  productPartId String?      @db.Uuid
  productPart   ProductPart? @relation("ProductPartAssignments", fields: [productPartId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Stampante assegnata
  printerId String  @db.Uuid
  printer   Printer @relation(fields: [printerId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  /// Relazione 1:1 (opzionale) per tracciare quale assignment "occupa" il piatto.
  /// È una relazione separata da `printer` quindi deve essere nominata.
  hasCompletedPrintOnBedOn Printer? @relation("BedOccupiedAssignment")

  /// Posizione in coda (0 = attuale, 1+ = in attesa)
  queuePosition Int              @default(0)
  status        AssignmentStatus @default(SCHEDULED)

  // === Timing ===
  scheduledAt DateTime? @db.Timestamptz(6) // Quando è stato schedulato
  /// Timestamp "claim" (lock) usato SOLO dallo scheduler backend per evitare doppio start.
  /// Non rappresenta l'inizio stampa: serve solo come mutex soft recuperabile (stale) in caso di crash.
  claimedAt   DateTime? @db.Timestamptz(6)
  startedAt   DateTime? @db.Timestamptz(6) // Inizio stampa effettivo
  completedAt DateTime? @db.Timestamptz(6) // Fine stampa

  /// Operazioni di raccolta pezzi associate a questa assegnazione
  harvests PrinterHarvest[]

  /// Operazioni di carico filamento associate
  filamentLoads PrinterFilamentLoad[]

  /// Run effettive collegate a questa assignment (storico esecuzioni reali).
  printRuns PrintRun[]

  /// Telemetria (opzionale) correlata a questa assignment:
  /// - eventi di cambio stato (quando si riesce a determinare assignmentId)
  /// - eventi di downtime correlati
  stateEvents    PrinterStateEvent[]    @relation("AssignmentStateEvents")
  downtimeEvents PrinterDowntimeEvent[] @relation("AssignmentDowntimeEvents")

  /// Issue operative/tecniche collegate a questa assignment (opzionale).
  issues PrinterIssue[]

  // === Conteggi parti ===
  partsExpected Int // Parti totali attese per questa stampa (micro-assignment)
  partsProduced Int @default(0) // Parti prodotte ok
  partsRejected Int @default(0) // Parti scartate

  // === Materiale ===
  /// Categoria materiale richiesto dal file (es. "PETG", "PLA")
  materialRequired  String?
  /// Colore richiesto (es. "RED", "BLACK")
  colorRequired     String?
  /// Se il materiale è stato cambiato per questo assignment
  materialChanged   Boolean   @default(false)
  /// Timestamp conferma cambio materiale
  materialChangedAt DateTime? @db.Timestamptz(6)

  // === Note ===
  notes String?

  /// Payload JSON per avvio stampa (usato dallo scheduler backend).
  /// Contiene tutte le informazioni per far partire la stampa anche a UI chiusa.
  /// Schema (v1): { version: 1, printerSerial, fileId?, filenameToPrint, plateNumber, useAms, amsMapping, options }
  startPayload Json?

  /// Task di accodamento persistenti (flusso "send to print")
  queueTasks QueueTask[] @relation("AssignmentQueueTasks")

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  /// Nota: NON usiamo più unique su (productionJobId, printerId) perché adottiamo la strategia
  /// "1 run = 1 assignment" (micro-assignments). Quindi per lo stesso job e la stessa stampante
  /// possono esistere più assignment (in coda).
  @@index([productionJobId, printerId])
  @@index([productionJobId])
  @@index([productPartId])
  @@index([printerId])
  @@index([status])
  @@index([queuePosition])
  @@schema("print-farm")
}

enum SoftwareType {
  BAMBU_STUDIO
  MAINSAIL

  @@schema("print-farm")
}

enum PrinterBrand {
  BAMBU_LAB
  KLIPPER
  PRUSA

  @@schema("print-farm")
}

enum FileStatus {
  DRAFT // Caricato, non ancora verificato
  TESTING // In fase di stampa di prova
  APPROVED // Validato per produzione massiva
  ARCHIVED // Versione vecchia, non usare
  REJECTED // Test falliti, da buttare

  @@schema("print-farm")
}

/// Operazione di raccolta pezzi stampati dalla stampante all'odette (harvesting).
/// Traccia chi ha effettuato la raccolta, quando, e la qualità dei pezzi.
model PrinterHarvest {
  id String @id @default(uuid()) @db.Uuid

  /// Assegnazione da cui provengono i pezzi
  assignmentId String            @db.Uuid
  assignment   PrinterAssignment @relation(fields: [assignmentId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  /// Stampante da cui è stata effettuata la raccolta
  printerId String  @db.Uuid
  printer   Printer @relation(fields: [printerId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  /// PrintRun associata a questa raccolta (opzionale).
  /// Utile per tracciare direttamente quale run ha prodotto i pezzi,
  /// specialmente per stampe unplanned/manuali dove l'assignment è meno significativa.
  printRunId String?   @db.Uuid
  printRun   PrintRun? @relation(fields: [printRunId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Odette di destinazione (opzionale).
  /// Serve per permettere lo scarico anche quando non c'è un contenitore disponibile.
  odetteId String? @db.Uuid
  odette   Odette? @relation(fields: [odetteId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Operatore che ha effettuato la raccolta
  harvestedByUserId Int
  harvestedByUser   User @relation("PrinterHarvests", fields: [harvestedByUserId], references: [id], onDelete: Restrict)

  /// Timestamp raccolta
  harvestedAt DateTime @default(now()) @db.Timestamptz(6)

  // === Conteggi pezzi ===
  /// Pezzi raccolti correttamente
  partsAccepted Int @default(0)
  /// Pezzi scartati (difetti, errori)
  partsRejected Int @default(0)
  /// Pezzi totali (accepted + rejected)
  partsTotal    Int @default(0)

  // === Qualità ===
  /// Motivo scarto (se ci sono pezzi rejected)
  rejectReason String?
  /// Note dell'operatore
  notes        String?
  /// Foto/immagine dei pezzi (opzionale)
  imageUrl     String?

  // === Lotto ===
  /// Lotto di produzione associato
  productionLotId String?        @db.Uuid
  productionLot   ProductionLot? @relation(fields: [productionLotId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([assignmentId])
  @@index([printerId])
  @@index([printRunId])
  @@index([odetteId])
  @@index([harvestedByUserId])
  @@index([harvestedAt])
  @@index([productionLotId])
  @@schema("print-farm")
}

/// Operazione di carico filamento/materiale sulla stampante.
/// Traccia il cambio bobina e la conferma di caricamento.
model PrinterFilamentLoad {
  id String @id @default(uuid()) @db.Uuid

  /// Assegnazione per cui viene effettuato il carico (opzionale)
  assignmentId String?            @db.Uuid
  assignment   PrinterAssignment? @relation(fields: [assignmentId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  /// Stampante su cui viene caricato
  printerId String  @db.Uuid
  printer   Printer @relation(fields: [printerId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  /// Operatore che ha effettuato il carico
  loadedByUserId Int
  loadedByUser   User @relation("PrinterFilamentLoads", fields: [loadedByUserId], references: [id], onDelete: Restrict)

  /// Timestamp carico
  loadedAt DateTime @default(now()) @db.Timestamptz(6)

  // === Contesto caricamento ===
  /// Motivo del carico filamento
  trigger FilamentLoadTrigger @default(MANUAL)

  /// Target: 'external' per bobina esterna, 'ams' per slot AMS
  targetKind String @default("external") @db.VarChar(10)
  /// Unità AMS (0-3). Null se targetKind = 'external'.
  amsUnit    Int?
  /// Slot AMS (0-3). Null se targetKind = 'external'.
  slot       Int?

  // === Dettagli materiale ===
  /// Bobina caricata
  spoolId          String?        @db.Uuid
  spool            FilamentSpool? @relation(fields: [spoolId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  /// Materiale precedente (per tracking cambio)
  previousMaterial String?
  /// Colore precedente
  previousColor    String?
  /// Materiale nuovo
  newMaterial      String?
  /// Colore nuovo
  newColor         String?

  // === Vecchia spool ===
  /// Spool che era montata prima del cambio
  oldSpoolId     String?        @db.Uuid
  /// Azione eseguita sulla vecchia spool
  oldSpoolAction String?        @db.VarChar(20)

  // === Tracking inventario (per undo) ===
  /// Movement USO creato durante il prelievo (null se spool parziale/manual)
  movementId String? @db.Uuid
  /// Item prelevato da inventario (null se spool parziale)
  itemId     String? @db.Uuid

  /// Conferma che il carico è stato completato correttamente
  confirmed   Boolean   @default(false)
  confirmedAt DateTime? @db.Timestamptz(6)

  /// True se l'operazione è stata annullata (undo)
  undone   Boolean   @default(false)
  undoneAt DateTime? @db.Timestamptz(6)

  /// Note dell'operatore
  notes String?

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([assignmentId])
  @@index([printerId])
  @@index([loadedByUserId])
  @@index([loadedAt])
  @@schema("print-farm")
}

enum FilamentLoadTrigger {
  MANUAL
  RUNOUT
  SWAP
  MISMATCH

  @@schema("print-farm")
}

/// Relazione M2M tra Printer e Category (solo per materiali).
/// Serve per gestire le "preferenze materiale" della stampante in modo type-safe.
/// Sostituisce il campo `Printer.preferredTags` (array di stringhe).
model PrinterPreferredMaterialCategory {
  printerId  String @db.Uuid
  categoryId String @db.Uuid

  printer  Printer  @relation(fields: [printerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@id([printerId, categoryId])
  @@index([printerId])
  @@index([categoryId])
  @@schema("print-farm")
}
