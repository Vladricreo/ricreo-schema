/// Perché: nella realtà un ordine ha più articoli; migliore reportistica.
model PurchaseOrder {
  id           String      @id @default(uuid()) @db.Uuid
  /// Progressivo numerico leggibile (BIGINT Postgres) per uso umano/reportistica.
  /// Nota: lasciamo `id` UUID come PK per non rompere relazioni/migrazioni; questo è solo un numero sequenziale.
  number       BigInt      @unique @default(autoincrement()) @db.BigInt
  supplierId   String      @db.Uuid
  status       OrderStatus
  createdAt    DateTime    @default(now()) @db.Timestamptz(6)
  updatedAt    DateTime    @default(now()) @updatedAt @db.Timestamptz(6)
  orderedAt    DateTime?   @db.Timestamptz(6)
  receivedAt   DateTime?   @db.Timestamptz(6)
  shippingCost Decimal?    @db.Decimal(12, 2)
  customsDuty  Decimal?    @db.Decimal(12, 2)

  supplier Supplier            @relation(fields: [supplierId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  lines    PurchaseOrderLine[]

  @@index([supplierId])
  @@index([status])
  @@index([orderedAt])
  @@schema("inventory")
}

/// Riga di un ordine di acquisto per un singolo Item (materia prima, componente, ecc.).
/// Collega quantità, prezzo e lotti di acquisto (InventoryLot) all'ordine fornitore.
model PurchaseOrderLine {
  id        String   @id @default(uuid()) @db.Uuid
  /// Progressivo numerico globale (BIGINT Postgres) per uso umano/reportistica.
  /// Se in futuro vuoi il progressivo "per ordine" (1..N), serve una strategia diversa (trigger/logic applicativa).
  number    BigInt   @unique @default(autoincrement()) @db.BigInt
  orderId   String   @db.Uuid
  /// Riferimento alla riga acquistata:
  /// - `itemId` per acquisti di Item (materie prime, componenti, packaging, ecc.)
  /// - `productPartId` per acquisti di ProductPart (parti esterne)
  /// Nota: una sola tra `itemId` e `productPartId` dovrebbe essere valorizzata.
  itemId         String? @db.Uuid
  productPartId  String? @db.Uuid
  quantity  Int
  /// MIGLIORIA: Decimal per prezzo riga
  pricePaid Decimal? @db.Decimal(12, 2)

  order PurchaseOrder @relation(fields: [orderId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  item        Item?        @relation(fields: [itemId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  productPart ProductPart? @relation(fields: [productPartId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  lots InventoryLot[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@index([orderId])
  @@index([itemId])
  @@index([productPartId])
  @@schema("inventory")
}

/// Definisce un fornitore da cui vengono acquistati gli 'Item'.
model Supplier {
  id                  String          @id @default(uuid()) @db.Uuid
  name                String          @unique
  website             String?
  email               String?
  leadTime            Int           @default(7)
  apiToken            String?
  apiKey              String?
  apiSecret           String?
  apiEndpoint         String?
  autoReorder         Boolean         @default(false)
  associatedItemTypes ItemType[]      @default([])
  items               Item[]
  /// Parti acquistabili collegate a questo fornitore (campo opposto di `ProductPart.supplier`).
  productParts        ProductPart[] @relation("SupplierProductParts")
  purchaseOrders      PurchaseOrder[]
  lots                InventoryLot[]

  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  @@schema("inventory")
}
